{
  "id": "/workspaces/Velocity/node_modules/@tomphttp/bare-client/dist/BareClient.js",
  "deps": [],
  "plugins": [
    "vite:load-fallback"
  ],
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "// The user likely has overwritten all networking functions after importing bare-client\r\n// It is our responsibility to make sure components of Bare-Client are using native networking functions\r\n// These exports are provided to plugins by @rollup/plugin-inject\r\nconst fetch = globalThis.fetch;\r\nconst WebSocket = globalThis.WebSocket;\r\nconst Request = globalThis.Request;\r\nconst Response = globalThis.Response;\n\nconst statusEmpty = [101, 204, 205, 304];\r\nconst statusRedirect = [301, 302, 303, 307, 308];\r\nclass BareError extends Error {\r\n    status;\r\n    body;\r\n    constructor(status, body) {\r\n        super(body.message || body.code);\r\n        this.status = status;\r\n        this.body = body;\r\n    }\r\n}\r\nclass Client {\r\n    base;\r\n    /**\r\n     *\r\n     * @param version Version provided by extension\r\n     * @param server Bare Server URL provided by BareClient\r\n     */\r\n    constructor(version, server) {\r\n        this.base = new URL(`./v${version}/`, server);\r\n    }\r\n}\n\nconst validChars = \"!#$%&'*+-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^_`abcdefghijklmnopqrstuvwxyz|~\";\r\nconst reserveChar = '%';\r\nfunction validProtocol(protocol) {\r\n    for (let i = 0; i < protocol.length; i++) {\r\n        const char = protocol[i];\r\n        if (!validChars.includes(char)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction encodeProtocol(protocol) {\r\n    let result = '';\r\n    for (let i = 0; i < protocol.length; i++) {\r\n        const char = protocol[i];\r\n        if (validChars.includes(char) && char !== reserveChar) {\r\n            result += char;\r\n        }\r\n        else {\r\n            const code = char.charCodeAt(0);\r\n            result += reserveChar + code.toString(16).padStart(2, '0');\r\n        }\r\n    }\r\n    return result;\r\n}\n\nclass ClientV1 extends Client {\r\n    ws;\r\n    http;\r\n    newMeta;\r\n    getMeta;\r\n    constructor(server) {\r\n        super(1, server);\r\n        this.ws = new URL(this.base);\r\n        this.http = new URL(this.base);\r\n        this.newMeta = new URL('ws-new-meta', this.base);\r\n        this.getMeta = new URL('ws-meta', this.base);\r\n        if (this.ws.protocol === 'https:') {\r\n            this.ws.protocol = 'wss:';\r\n        }\r\n        else {\r\n            this.ws.protocol = 'ws:';\r\n        }\r\n    }\r\n    async connect(requestHeaders, protocol, host, port, path) {\r\n        const assignMeta = await fetch(this.newMeta, { method: 'GET' });\r\n        if (!assignMeta.ok) {\r\n            throw new BareError(assignMeta.status, await assignMeta.json());\r\n        }\r\n        const id = await assignMeta.text();\r\n        const socket = new WebSocket(this.ws, [\r\n            'bare',\r\n            encodeProtocol(JSON.stringify({\r\n                remote: {\r\n                    protocol,\r\n                    host,\r\n                    port,\r\n                    path,\r\n                },\r\n                headers: requestHeaders,\r\n                forward_headers: [\r\n                    'accept-encoding',\r\n                    'accept-language',\r\n                    'sec-websocket-extensions',\r\n                    'sec-websocket-key',\r\n                    'sec-websocket-version',\r\n                ],\r\n                id,\r\n            })),\r\n        ]);\r\n        socket.meta = new Promise((resolve, reject) => {\r\n            socket.addEventListener('open', async () => {\r\n                const outgoing = await fetch(this.getMeta, {\r\n                    headers: {\r\n                        'x-bare-id': id,\r\n                    },\r\n                    method: 'GET',\r\n                });\r\n                if (!outgoing.ok) {\r\n                    reject(new BareError(outgoing.status, await outgoing.json()));\r\n                }\r\n                resolve(await outgoing.json());\r\n            });\r\n            socket.addEventListener('error', reject);\r\n        });\r\n        return socket;\r\n    }\r\n    async request(method, requestHeaders, body, protocol, host, port, path, cache, signal) {\r\n        if (protocol.startsWith('blob:')) {\r\n            const response = await fetch(`${protocol}${host}${path}`);\r\n            const result = new Response(response.body, response);\r\n            result.rawHeaders = Object.fromEntries(response.headers);\r\n            result.rawResponse = response;\r\n            return result;\r\n        }\r\n        const bareHeaders = {};\r\n        if (requestHeaders instanceof Headers) {\r\n            for (const [header, value] of requestHeaders) {\r\n                bareHeaders[header] = value;\r\n            }\r\n        }\r\n        else {\r\n            for (const header in requestHeaders) {\r\n                bareHeaders[header] = requestHeaders[header];\r\n            }\r\n        }\r\n        const forwardHeaders = ['accept-encoding', 'accept-language'];\r\n        const options = {\r\n            credentials: 'omit',\r\n            method: method,\r\n            signal,\r\n        };\r\n        if (body !== undefined) {\r\n            options.body = body;\r\n        }\r\n        // bare can be an absolute path containing no origin, it becomes relative to the script\r\n        const request = new Request(this.http, options);\r\n        this.writeBareRequest(request, protocol, host, path, port, bareHeaders, forwardHeaders);\r\n        const response = await fetch(request);\r\n        const readResponse = await this.readBareResponse(response);\r\n        const result = new Response(statusEmpty.includes(readResponse.status) ? undefined : response.body, {\r\n            status: readResponse.status,\r\n            statusText: readResponse.statusText ?? undefined,\r\n            headers: readResponse.headers,\r\n        });\r\n        result.rawHeaders = readResponse.rawHeaders;\r\n        result.rawResponse = response;\r\n        return result;\r\n    }\r\n    async readBareResponse(response) {\r\n        if (!response.ok) {\r\n            throw new BareError(response.status, await response.json());\r\n        }\r\n        const requiredHeaders = [\r\n            'x-bare-status',\r\n            'x-bare-status-text',\r\n            'x-bare-headers',\r\n        ];\r\n        for (const header of requiredHeaders) {\r\n            if (!response.headers.has(header)) {\r\n                throw new BareError(500, {\r\n                    code: 'IMPL_MISSING_BARE_HEADER',\r\n                    id: `response.headers.${header}`,\r\n                });\r\n            }\r\n        }\r\n        const status = parseInt(response.headers.get('x-bare-status'));\r\n        const statusText = response.headers.get('x-bare-status-text');\r\n        const rawHeaders = JSON.parse(response.headers.get('x-bare-headers'));\r\n        const headers = new Headers(rawHeaders);\r\n        return {\r\n            status,\r\n            statusText,\r\n            rawHeaders,\r\n            headers,\r\n        };\r\n    }\r\n    writeBareRequest(request, protocol, host, path, port, bareHeaders, forwardHeaders) {\r\n        request.headers.set('x-bare-protocol', protocol);\r\n        request.headers.set('x-bare-host', host);\r\n        request.headers.set('x-bare-path', path);\r\n        request.headers.set('x-bare-port', port.toString());\r\n        request.headers.set('x-bare-headers', JSON.stringify(bareHeaders));\r\n        request.headers.set('x-bare-forward-headers', JSON.stringify(forwardHeaders));\r\n    }\r\n}\n\n/*\r\n * JavaScript MD5\r\n * Adopted from https://github.com/blueimp/JavaScript-MD5\r\n *\r\n * Copyright 2011, Sebastian Tschan\r\n * https://blueimp.net\r\n *\r\n * Licensed under the MIT license:\r\n * https://opensource.org/licenses/MIT\r\n *\r\n * Based on\r\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\r\n * Digest Algorithm, as defined in RFC 1321.\r\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\r\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\r\n * Distributed under the BSD License\r\n * See http://pajhome.org.uk/crypt/md5 for more info.\r\n */\r\n/**\r\n * Add integers, wrapping at 2^32.\r\n * This uses 16-bit operations internally to work around bugs in interpreters.\r\n *\r\n * @param x First integer\r\n * @param y Second integer\r\n * @returns Sum\r\n */\r\nfunction safeAdd(x, y) {\r\n    const lsw = (x & 0xffff) + (y & 0xffff);\r\n    const msw = (x >> 16) + (y >> 16) + (lsw >> 16);\r\n    return (msw << 16) | (lsw & 0xffff);\r\n}\r\n/**\r\n * Bitwise rotate a 32-bit number to the left.\r\n *\r\n * @param num 32-bit number\r\n * @param cnt Rotation count\r\n * @returns  Rotated number\r\n */\r\nfunction bitRotateLeft(num, cnt) {\r\n    return (num << cnt) | (num >>> (32 - cnt));\r\n}\r\n/**\r\n * Basic operation the algorithm uses.\r\n *\r\n * @param q q\r\n * @param a a\r\n * @param b b\r\n * @param x x\r\n * @param s s\r\n * @param t t\r\n * @returns Result\r\n */\r\nfunction md5cmn(q, a, b, x, s, t) {\r\n    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\r\n}\r\n/**\r\n * Basic operation the algorithm uses.\r\n *\r\n * @param a a\r\n * @param b b\r\n * @param c c\r\n * @param d d\r\n * @param x x\r\n * @param s s\r\n * @param t t\r\n * @returns Result\r\n */\r\nfunction md5ff(a, b, c, d, x, s, t) {\r\n    return md5cmn((b & c) | (~b & d), a, b, x, s, t);\r\n}\r\n/**\r\n * Basic operation the algorithm uses.\r\n *\r\n * @param a a\r\n * @param b b\r\n * @param c c\r\n * @param d d\r\n * @param x x\r\n * @param s s\r\n * @param t t\r\n * @returns Result\r\n */\r\nfunction md5gg(a, b, c, d, x, s, t) {\r\n    return md5cmn((b & d) | (c & ~d), a, b, x, s, t);\r\n}\r\n/**\r\n * Basic operation the algorithm uses.\r\n *\r\n * @param a a\r\n * @param b b\r\n * @param c c\r\n * @param d d\r\n * @param x x\r\n * @param s s\r\n * @param t t\r\n * @returns Result\r\n */\r\nfunction md5hh(a, b, c, d, x, s, t) {\r\n    return md5cmn(b ^ c ^ d, a, b, x, s, t);\r\n}\r\n/**\r\n * Basic operation the algorithm uses.\r\n *\r\n * @param a a\r\n * @param b b\r\n * @param c c\r\n * @param d d\r\n * @param x x\r\n * @param s s\r\n * @param t t\r\n * @returns Result\r\n */\r\nfunction md5ii(a, b, c, d, x, s, t) {\r\n    return md5cmn(c ^ (b | ~d), a, b, x, s, t);\r\n}\r\n/**\r\n * Calculate the MD5 of an array of little-endian words, and a bit length.\r\n *\r\n * @param x Array of little-endian words\r\n * @param len Bit length\r\n * @returns MD5 Array\r\n */\r\nfunction binlMD5(x, len) {\r\n    /* append padding */\r\n    x[len >> 5] |= 0x80 << len % 32;\r\n    x[(((len + 64) >>> 9) << 4) + 14] = len;\r\n    let a = 1732584193;\r\n    let b = -271733879;\r\n    let c = -1732584194;\r\n    let d = 271733878;\r\n    for (let i = 0; i < x.length; i += 16) {\r\n        const olda = a;\r\n        const oldb = b;\r\n        const oldc = c;\r\n        const oldd = d;\r\n        a = md5ff(a, b, c, d, x[i], 7, -680876936);\r\n        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\r\n        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\r\n        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\r\n        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\r\n        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\r\n        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\r\n        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\r\n        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\r\n        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\r\n        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\r\n        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\r\n        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\r\n        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\r\n        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\r\n        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\r\n        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\r\n        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\r\n        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\r\n        b = md5gg(b, c, d, a, x[i], 20, -373897302);\r\n        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\r\n        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\r\n        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\r\n        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\r\n        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\r\n        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\r\n        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\r\n        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\r\n        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\r\n        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\r\n        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\r\n        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\r\n        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\r\n        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\r\n        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\r\n        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\r\n        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\r\n        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\r\n        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\r\n        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\r\n        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\r\n        d = md5hh(d, a, b, c, x[i], 11, -358537222);\r\n        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\r\n        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\r\n        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\r\n        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\r\n        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\r\n        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\r\n        a = md5ii(a, b, c, d, x[i], 6, -198630844);\r\n        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\r\n        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\r\n        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\r\n        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\r\n        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\r\n        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\r\n        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\r\n        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\r\n        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\r\n        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\r\n        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\r\n        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\r\n        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\r\n        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\r\n        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\r\n        a = safeAdd(a, olda);\r\n        b = safeAdd(b, oldb);\r\n        c = safeAdd(c, oldc);\r\n        d = safeAdd(d, oldd);\r\n    }\r\n    return [a, b, c, d];\r\n}\r\n/**\r\n * Convert an array of little-endian words to a string\r\n *\r\n * @param input MD5 Array\r\n * @returns MD5 string\r\n */\r\nfunction binl2rstr(input) {\r\n    let output = '';\r\n    const length32 = input.length * 32;\r\n    for (let i = 0; i < length32; i += 8) {\r\n        output += String.fromCharCode((input[i >> 5] >>> i % 32) & 0xff);\r\n    }\r\n    return output;\r\n}\r\n/**\r\n * Convert a raw string to an array of little-endian words\r\n * Characters >255 have their high-byte silently ignored.\r\n *\r\n * @param input Raw input string\r\n * @returns Array of little-endian words\r\n */\r\nfunction rstr2binl(input) {\r\n    const output = [];\r\n    const outputLen = input.length >> 2;\r\n    for (let i = 0; i < outputLen; i += 1) {\r\n        output[i] = 0;\r\n    }\r\n    const length8 = input.length * 8;\r\n    for (let i = 0; i < length8; i += 8) {\r\n        output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << i % 32;\r\n    }\r\n    return output;\r\n}\r\n/**\r\n * Calculate the MD5 of a raw string\r\n *\r\n * @param s Input string\r\n * @returns Raw MD5 string\r\n */\r\nfunction rstrMD5(s) {\r\n    return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));\r\n}\r\n/**\r\n * Calculates the HMAC-MD5 of a key and some data (raw strings)\r\n *\r\n * @param key HMAC key\r\n * @param data Raw input string\r\n * @returns Raw MD5 string\r\n */\r\nfunction rstrHMACMD5(key, data) {\r\n    let bkey = rstr2binl(key);\r\n    const ipad = [];\r\n    const opad = [];\r\n    if (bkey.length > 16) {\r\n        bkey = binlMD5(bkey, key.length * 8);\r\n    }\r\n    for (let i = 0; i < 16; i += 1) {\r\n        ipad[i] = bkey[i] ^ 0x36363636;\r\n        opad[i] = bkey[i] ^ 0x5c5c5c5c;\r\n    }\r\n    const hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);\r\n    return binl2rstr(binlMD5(opad.concat(hash), 512 + 128));\r\n}\r\n/**\r\n * Convert a raw string to a hex string\r\n *\r\n * @param input Raw input string\r\n * @returns Hex encoded string\r\n */\r\nfunction rstr2hex(input) {\r\n    const hexTab = '0123456789abcdef';\r\n    let output = '';\r\n    for (let i = 0; i < input.length; i += 1) {\r\n        const x = input.charCodeAt(i);\r\n        output += hexTab.charAt((x >>> 4) & 0x0f) + hexTab.charAt(x & 0x0f);\r\n    }\r\n    return output;\r\n}\r\n/**\r\n * Encode a string as UTF-8\r\n *\r\n * @param input Input string\r\n * @returns UTF8 string\r\n */\r\nfunction str2rstrUTF8(input) {\r\n    return unescape(encodeURIComponent(input));\r\n}\r\n/**\r\n * Encodes input string as raw MD5 string\r\n *\r\n * @param s Input string\r\n * @returns Raw MD5 string\r\n */\r\nfunction rawMD5(s) {\r\n    return rstrMD5(str2rstrUTF8(s));\r\n}\r\n/**\r\n * Encodes input string as Hex encoded string\r\n *\r\n * @param s Input string\r\n * @returns Hex encoded string\r\n */\r\nfunction hexMD5(s) {\r\n    return rstr2hex(rawMD5(s));\r\n}\r\n/**\r\n * Calculates the raw HMAC-MD5 for the given key and data\r\n *\r\n * @param k HMAC key\r\n * @param d Input string\r\n * @returns Raw MD5 string\r\n */\r\nfunction rawHMACMD5(k, d) {\r\n    return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d));\r\n}\r\n/**\r\n * Calculates the Hex encoded HMAC-MD5 for the given key and data\r\n *\r\n * @param k HMAC key\r\n * @param d Input string\r\n * @returns Raw MD5 string\r\n */\r\nfunction hexHMACMD5(k, d) {\r\n    return rstr2hex(rawHMACMD5(k, d));\r\n}\r\n/**\r\n * Calculates MD5 value for a given string.\r\n * If a key is provided, calculates the HMAC-MD5 value.\r\n * Returns a Hex encoded string unless the raw argument is given.\r\n *\r\n * @param string Input string\r\n * @param key HMAC key\r\n * @param raw Raw output switch\r\n * @returns MD5 output\r\n */\r\nfunction md5(string, key, raw) {\r\n    if (!key) {\r\n        if (!raw) {\r\n            return hexMD5(string);\r\n        }\r\n        return rawMD5(string);\r\n    }\r\n    if (!raw) {\r\n        return hexHMACMD5(key, string);\r\n    }\r\n    return rawHMACMD5(key, string);\r\n}\n\nconst MAX_HEADER_VALUE = 3072;\r\n/**\r\n *\r\n * Splits headers according to spec\r\n * @param headers\r\n * @returns Split headers\r\n */\r\nfunction splitHeaders(headers) {\r\n    const output = new Headers(headers);\r\n    if (headers.has('x-bare-headers')) {\r\n        const value = headers.get('x-bare-headers');\r\n        if (value.length > MAX_HEADER_VALUE) {\r\n            output.delete('x-bare-headers');\r\n            let split = 0;\r\n            for (let i = 0; i < value.length; i += MAX_HEADER_VALUE) {\r\n                const part = value.slice(i, i + MAX_HEADER_VALUE);\r\n                const id = split++;\r\n                output.set(`x-bare-headers-${id}`, `;${part}`);\r\n            }\r\n        }\r\n    }\r\n    return output;\r\n}\r\n/**\r\n * Joins headers according to spec\r\n * @param headers\r\n * @returns Joined headers\r\n */\r\nfunction joinHeaders(headers) {\r\n    const output = new Headers(headers);\r\n    const prefix = 'x-bare-headers';\r\n    if (headers.has(`${prefix}-0`)) {\r\n        const join = [];\r\n        for (const [header, value] of headers) {\r\n            if (!header.startsWith(prefix)) {\r\n                continue;\r\n            }\r\n            if (!value.startsWith(';')) {\r\n                throw new BareError(400, {\r\n                    code: 'INVALID_BARE_HEADER',\r\n                    id: `request.headers.${header}`,\r\n                    message: `Value didn't begin with semi-colon.`,\r\n                });\r\n            }\r\n            const id = parseInt(header.slice(prefix.length + 1));\r\n            join[id] = value.slice(1);\r\n            output.delete(header);\r\n        }\r\n        output.set(prefix, join.join(''));\r\n    }\r\n    return output;\r\n}\n\nclass ClientV2 extends Client {\r\n    ws;\r\n    http;\r\n    newMeta;\r\n    getMeta;\r\n    constructor(server) {\r\n        super(2, server);\r\n        this.ws = new URL(this.base);\r\n        this.http = new URL(this.base);\r\n        this.newMeta = new URL('./ws-new-meta', this.base);\r\n        this.getMeta = new URL(`./ws-meta`, this.base);\r\n        if (this.ws.protocol === 'https:') {\r\n            this.ws.protocol = 'wss:';\r\n        }\r\n        else {\r\n            this.ws.protocol = 'ws:';\r\n        }\r\n    }\r\n    async connect(requestHeaders, protocol, host, port, path) {\r\n        const request = new Request(this.newMeta, {\r\n            headers: this.createBareHeaders(protocol, host, path, port, requestHeaders),\r\n        });\r\n        const assignMeta = await fetch(request);\r\n        if (!assignMeta.ok) {\r\n            throw new BareError(assignMeta.status, await assignMeta.json());\r\n        }\r\n        const id = await assignMeta.text();\r\n        const socket = new WebSocket(this.ws, [\r\n            id,\r\n        ]);\r\n        socket.meta = new Promise((resolve, reject) => {\r\n            socket.addEventListener('open', async () => {\r\n                const outgoing = await fetch(this.getMeta, {\r\n                    headers: {\r\n                        'x-bare-id': id,\r\n                    },\r\n                    method: 'GET',\r\n                });\r\n                resolve(await this.readBareResponse(outgoing));\r\n            });\r\n            socket.addEventListener('error', reject);\r\n        });\r\n        return socket;\r\n    }\r\n    async request(method, requestHeaders, body, protocol, host, port, path, cache, signal) {\r\n        if (protocol.startsWith('blob:')) {\r\n            const response = await fetch(`${protocol}${host}${path}`);\r\n            const result = new Response(response.body, response);\r\n            result.rawHeaders = Object.fromEntries(response.headers);\r\n            result.rawResponse = response;\r\n            return result;\r\n        }\r\n        const bareHeaders = {};\r\n        if (requestHeaders instanceof Headers) {\r\n            for (const [header, value] of requestHeaders) {\r\n                bareHeaders[header] = value;\r\n            }\r\n        }\r\n        else {\r\n            for (const header in requestHeaders) {\r\n                bareHeaders[header] = requestHeaders[header];\r\n            }\r\n        }\r\n        const options = {\r\n            credentials: 'omit',\r\n            method: method,\r\n            signal,\r\n        };\r\n        if (cache !== 'only-if-cached') {\r\n            options.cache = cache;\r\n        }\r\n        if (body !== undefined) {\r\n            options.body = body;\r\n        }\r\n        options.headers = this.createBareHeaders(protocol, host, path, port, bareHeaders);\r\n        const request = new Request(this.http + '?cache=' + md5(`${protocol}${host}${port}${path}`), options);\r\n        const response = await fetch(request);\r\n        const readResponse = await this.readBareResponse(response);\r\n        const result = new Response(statusEmpty.includes(readResponse.status) ? undefined : response.body, {\r\n            status: readResponse.status,\r\n            statusText: readResponse.statusText ?? undefined,\r\n            headers: readResponse.headers,\r\n        });\r\n        result.rawHeaders = readResponse.rawHeaders;\r\n        result.rawResponse = response;\r\n        return result;\r\n    }\r\n    async readBareResponse(response) {\r\n        if (!response.ok) {\r\n            throw new BareError(response.status, await response.json());\r\n        }\r\n        const responseHeaders = joinHeaders(response.headers);\r\n        const result = {};\r\n        if (responseHeaders.has('x-bare-status')) {\r\n            result.status = parseInt(responseHeaders.get('x-bare-status'));\r\n        }\r\n        if (responseHeaders.has('x-bare-status-text')) {\r\n            result.statusText = responseHeaders.get('x-bare-status-text');\r\n        }\r\n        if (responseHeaders.has('x-bare-headers')) {\r\n            result.rawHeaders = JSON.parse(responseHeaders.get('x-bare-headers'));\r\n            result.headers = new Headers(result.rawHeaders);\r\n        }\r\n        return result;\r\n    }\r\n    createBareHeaders(protocol, host, path, port, bareHeaders, forwardHeaders = [], passHeaders = [], passStatus = []) {\r\n        const headers = new Headers();\r\n        headers.set('x-bare-protocol', protocol);\r\n        headers.set('x-bare-host', host);\r\n        headers.set('x-bare-path', path);\r\n        headers.set('x-bare-port', port.toString());\r\n        headers.set('x-bare-headers', JSON.stringify(bareHeaders));\r\n        for (const header of forwardHeaders) {\r\n            headers.append('x-bare-forward-headers', header);\r\n        }\r\n        for (const header of passHeaders) {\r\n            headers.append('x-bare-pass-headers', header);\r\n        }\r\n        for (const status of passStatus) {\r\n            headers.append('x-bare-pass-status', status.toString());\r\n        }\r\n        splitHeaders(headers);\r\n        return headers;\r\n    }\r\n}\n\nconst clientCtors = [\r\n    ['v2', ClientV2],\r\n    ['v1', ClientV1],\r\n];\r\nconst maxRedirects = 20;\r\nasync function fetchManifest(server, signal) {\r\n    const outgoing = await fetch(server, { signal });\r\n    if (!outgoing.ok) {\r\n        throw new Error(`Unable to fetch Bare meta: ${outgoing.status} ${await outgoing.text()}`);\r\n    }\r\n    return await outgoing.json();\r\n}\r\nfunction resolvePort(url) {\r\n    if (url.port)\r\n        return Number(url.port);\r\n    switch (url.protocol) {\r\n        case 'ws:':\r\n        case 'http:':\r\n            return 80;\r\n        case 'wss:':\r\n        case 'https:':\r\n            return 443;\r\n        default:\r\n            // maybe blob\r\n            return 0;\r\n    }\r\n}\r\nclass BareClient {\r\n    /**\r\n     * @depricated Use .manifest instead.\r\n     */\r\n    get data() {\r\n        return this.manfiest;\r\n    }\r\n    manfiest;\r\n    client;\r\n    server;\r\n    working;\r\n    onDemand;\r\n    onDemandSignal;\r\n    constructor(server, _) {\r\n        this.server = new URL(server);\r\n        if (!_ || _ instanceof AbortSignal) {\r\n            this.onDemand = true;\r\n            this.onDemandSignal = _;\r\n        }\r\n        else {\r\n            this.onDemand = false;\r\n            this.manfiest = _;\r\n            this.getClient();\r\n        }\r\n    }\r\n    demand() {\r\n        if (!this.onDemand)\r\n            return;\r\n        if (!this.working)\r\n            this.working = fetchManifest(this.server, this.onDemandSignal)\r\n                .then((manfiest) => {\r\n                this.manfiest = manfiest;\r\n                this.getClient();\r\n            })\r\n                .catch((err) => {\r\n                // allow the next request to re-fetch the manifest\r\n                // this is to prevent BareClient from permanently failing when used on demand\r\n                delete this.working;\r\n                throw err;\r\n            });\r\n        return this.working;\r\n    }\r\n    getClient() {\r\n        // newest-oldest\r\n        for (const [version, ctor] of clientCtors) {\r\n            if (this.data.versions.includes(version)) {\r\n                this.client = new ctor(this.server);\r\n                return;\r\n            }\r\n        }\r\n        throw new Error(`Unable to find compatible client version.`);\r\n    }\r\n    async request(method, requestHeaders, body, protocol, host, port, path, cache, signal) {\r\n        await this.demand();\r\n        return await this.client.request(method, requestHeaders, body, protocol, host, port, path, cache, signal);\r\n    }\r\n    async connect(requestHeaders, protocol, host, port, path) {\r\n        await this.demand();\r\n        return this.client.connect(requestHeaders, protocol, host, port, path);\r\n    }\r\n    /**\r\n     *\r\n     * @param url\r\n     * @param headers\r\n     * @param protocols\r\n     * @returns\r\n     */\r\n    createWebSocket(url, headers = {}, protocols = []) {\r\n        const requestHeaders = headers instanceof Headers ? Object.fromEntries(headers) : headers;\r\n        url = new URL(url);\r\n        // user is expected to specify user-agent and origin\r\n        // both are in spec\r\n        requestHeaders['Host'] = url.host;\r\n        // requestHeaders['Origin'] = origin;\r\n        requestHeaders['Pragma'] = 'no-cache';\r\n        requestHeaders['Cache-Control'] = 'no-cache';\r\n        requestHeaders['Upgrade'] = 'websocket';\r\n        // requestHeaders['User-Agent'] = navigator.userAgent;\r\n        requestHeaders['Connection'] = 'Upgrade';\r\n        if (typeof protocols === 'string') {\r\n            protocols = [protocols];\r\n        }\r\n        for (const proto of protocols) {\r\n            if (!validProtocol(proto)) {\r\n                throw new DOMException(`Failed to construct 'WebSocket': The subprotocol '${proto}' is invalid.`);\r\n            }\r\n        }\r\n        if (protocols.length)\r\n            requestHeaders['Sec-Websocket-Protocol'] = protocols.join(', ');\r\n        return this.connect(requestHeaders, url.protocol, url.hostname, resolvePort(url), url.pathname + url.search);\r\n    }\r\n    async fetch(url, init = {}) {\r\n        if (url instanceof Request) {\r\n            // behave similar to the browser when fetch is called with (Request, Init)\r\n            if (init) {\r\n                url = new URL(url.url);\r\n            }\r\n            else {\r\n                init = url;\r\n                url = new URL(url.url);\r\n            }\r\n        }\r\n        else {\r\n            url = new URL(url);\r\n        }\r\n        let method;\r\n        if (typeof init.method === 'string') {\r\n            method = init.method;\r\n        }\r\n        else {\r\n            method = 'GET';\r\n        }\r\n        let body;\r\n        if (init.body !== undefined && init.body !== null) {\r\n            body = init.body;\r\n        }\r\n        let headers;\r\n        if (typeof init.headers === 'object' && init.headers !== null) {\r\n            if (init.headers instanceof Headers) {\r\n                headers = Object.fromEntries(init.headers);\r\n            }\r\n            else {\r\n                headers = init.headers;\r\n            }\r\n        }\r\n        else {\r\n            headers = {};\r\n        }\r\n        let cache;\r\n        if (typeof init.cache === 'string') {\r\n            cache = init.cache;\r\n        }\r\n        else {\r\n            cache = 'default';\r\n        }\r\n        let signal;\r\n        if (init.signal instanceof AbortSignal) {\r\n            signal = init.signal;\r\n        }\r\n        for (let i = 0;; i++) {\r\n            if ('host' in headers)\r\n                headers.host = url.host;\r\n            else\r\n                headers.Host = url.host;\r\n            const response = await this.request(method, headers, body, url.protocol, url.hostname, resolvePort(url), url.pathname + url.search, cache, signal);\r\n            response.finalURL = url.toString();\r\n            if (statusRedirect.includes(response.status)) {\r\n                switch (init.redirect) {\r\n                    default:\r\n                    case 'follow':\r\n                        if (maxRedirects > i && response.headers.has('location')) {\r\n                            url = new URL(response.headers.get('location'), url);\r\n                            continue;\r\n                        }\r\n                        else {\r\n                            throw new TypeError('Failed to fetch');\r\n                        }\r\n                    case 'error':\r\n                        throw new TypeError('Failed to fetch');\r\n                    case 'manual':\r\n                        return response;\r\n                }\r\n            }\r\n            else {\r\n                return response;\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n *\r\n * Facilitates fetching the Bare server and constructing a BareClient.\r\n * @param server Bare server\r\n * @param signal Abort signal when fetching the manifest\r\n */\r\nasync function createBareClient(server, signal) {\r\n    const manfiest = await fetchManifest(server, signal);\r\n    return new BareClient(server, manfiest);\r\n}\n\nexport { BareError, createBareClient, BareClient as default, maxRedirects, statusEmpty, statusRedirect };\n//# sourceMappingURL=BareClient.js.map\n",
      "start": 1681131423973,
      "end": 1681131424297
    }
  ],
  "virtual": false
}