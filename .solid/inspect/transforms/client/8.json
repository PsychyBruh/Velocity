{
  "id": "/workspaces/Velocity/node_modules/@thisbeyond/solid-dnd/dist/index.jsx",
  "deps": [],
  "plugins": [
    "vite:load-fallback",
    "solid"
  ],
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "// src/drag-drop-context.tsx\nimport {\n  batch,\n  createContext,\n  createEffect,\n  mergeProps,\n  untrack,\n  useContext\n} from \"solid-js\";\nimport { createStore } from \"solid-js/store\";\n\n// src/layout.ts\nvar Layout = class {\n  x;\n  y;\n  width;\n  height;\n  constructor(rect) {\n    this.x = Math.floor(rect.x);\n    this.y = Math.floor(rect.y);\n    this.width = Math.floor(rect.width);\n    this.height = Math.floor(rect.height);\n  }\n  get rect() {\n    return { x: this.x, y: this.y, width: this.width, height: this.height };\n  }\n  get left() {\n    return this.x;\n  }\n  get top() {\n    return this.y;\n  }\n  get right() {\n    return this.x + this.width;\n  }\n  get bottom() {\n    return this.y + this.height;\n  }\n  get center() {\n    return {\n      x: this.x + this.width * 0.5,\n      y: this.y + this.height * 0.5\n    };\n  }\n  get corners() {\n    return {\n      topLeft: { x: this.left, y: this.top },\n      topRight: { x: this.right, y: this.top },\n      bottomRight: { x: this.left, y: this.bottom },\n      bottomLeft: { x: this.right, y: this.bottom }\n    };\n  }\n};\nvar elementLayout = (element) => {\n  let layout = new Layout(element.getBoundingClientRect());\n  const { transform } = getComputedStyle(element);\n  if (transform) {\n    layout = stripTransformFromLayout(layout, transform);\n  }\n  return layout;\n};\nvar stripTransformFromLayout = (layout, transform) => {\n  let translateX, translateY;\n  if (transform.startsWith(\"matrix3d(\")) {\n    const matrix = transform.slice(9, -1).split(/, /);\n    translateX = +matrix[12];\n    translateY = +matrix[13];\n  } else if (transform.startsWith(\"matrix(\")) {\n    const matrix = transform.slice(7, -1).split(/, /);\n    translateX = +matrix[4];\n    translateY = +matrix[5];\n  } else {\n    translateX = 0;\n    translateY = 0;\n  }\n  return new Layout({\n    ...layout,\n    x: layout.x - translateX,\n    y: layout.y - translateY\n  });\n};\nvar noopTransform = () => ({ x: 0, y: 0 });\nvar transformsAreEqual = (firstTransform, secondTransform) => {\n  return firstTransform.x === secondTransform.x && firstTransform.y === secondTransform.y;\n};\nvar transformLayout = (layout, transform) => {\n  return new Layout({\n    ...layout,\n    x: layout.x + transform.x,\n    y: layout.y + transform.y\n  });\n};\nvar distanceBetweenPoints = (firstPoint, secondPoint) => {\n  return Math.sqrt(\n    Math.pow(firstPoint.x - secondPoint.x, 2) + Math.pow(firstPoint.y - secondPoint.y, 2)\n  );\n};\nvar intersectionRatioOfLayouts = (firstLayout, secondLayout) => {\n  const top = Math.max(firstLayout.top, secondLayout.top);\n  const left = Math.max(firstLayout.left, secondLayout.left);\n  const right = Math.min(firstLayout.right, secondLayout.right);\n  const bottom = Math.min(firstLayout.bottom, secondLayout.bottom);\n  const width = right - left;\n  const height = bottom - top;\n  if (left < right && top < bottom) {\n    const layout1Area = firstLayout.width * firstLayout.height;\n    const layout2Area = secondLayout.width * secondLayout.height;\n    const intersectionArea = width * height;\n    return intersectionArea / (layout1Area + layout2Area - intersectionArea);\n  }\n  return 0;\n};\nvar layoutsAreEqual = (firstLayout, secondLayout) => {\n  return firstLayout.x === secondLayout.x && firstLayout.y === secondLayout.y && firstLayout.width === secondLayout.width && firstLayout.height === secondLayout.height;\n};\n\n// src/collision.ts\nvar closestCenter = (draggable, droppables, context) => {\n  const point1 = draggable.transformed.center;\n  const collision = { distance: Infinity, droppable: null };\n  for (const droppable of droppables) {\n    const distance = distanceBetweenPoints(point1, droppable.layout.center);\n    if (distance < collision.distance) {\n      collision.distance = distance;\n      collision.droppable = droppable;\n    } else if (distance === collision.distance && droppable.id === context.activeDroppableId) {\n      collision.droppable = droppable;\n    }\n  }\n  return collision.droppable;\n};\nvar closestCorners = (draggable, droppables, context) => {\n  const draggableCorners = draggable.transformed.corners;\n  const collision = { distance: Infinity, droppable: null };\n  for (const droppable of droppables) {\n    const droppableCorners = droppable.layout.corners;\n    const distance = distanceBetweenPoints(\n      droppableCorners.topLeft,\n      draggableCorners.topLeft\n    ) + distanceBetweenPoints(\n      droppableCorners.topRight,\n      draggableCorners.topRight\n    ) + distanceBetweenPoints(\n      droppableCorners.bottomRight,\n      draggableCorners.bottomRight\n    ) + distanceBetweenPoints(\n      droppableCorners.bottomLeft,\n      draggableCorners.bottomLeft\n    );\n    if (distance < collision.distance) {\n      collision.distance = distance;\n      collision.droppable = droppable;\n    } else if (distance === collision.distance && droppable.id === context.activeDroppableId) {\n      collision.droppable = droppable;\n    }\n  }\n  return collision.droppable;\n};\nvar mostIntersecting = (draggable, droppables, context) => {\n  const draggableLayout = draggable.transformed;\n  const collision = { ratio: 0, droppable: null };\n  for (const droppable of droppables) {\n    const ratio = intersectionRatioOfLayouts(draggableLayout, droppable.layout);\n    if (ratio > collision.ratio) {\n      collision.ratio = ratio;\n      collision.droppable = droppable;\n    } else if (ratio > 0 && ratio === collision.ratio && droppable.id === context.activeDroppableId) {\n      collision.droppable = droppable;\n    }\n  }\n  return collision.droppable;\n};\n\n// src/drag-drop-context.tsx\nvar Context = createContext();\nvar DragDropProvider = (passedProps) => {\n  const props = mergeProps(\n    { collisionDetector: mostIntersecting },\n    passedProps\n  );\n  const [state, setState] = createStore({\n    draggables: {},\n    droppables: {},\n    sensors: {},\n    active: {\n      draggableId: null,\n      get draggable() {\n        return state.active.draggableId !== null ? state.draggables[state.active.draggableId] : null;\n      },\n      droppableId: null,\n      get droppable() {\n        return state.active.droppableId !== null ? state.droppables[state.active.droppableId] : null;\n      },\n      sensorId: null,\n      get sensor() {\n        return state.active.sensorId !== null ? state.sensors[state.active.sensorId] : null;\n      },\n      overlay: null\n    }\n  });\n  const addTransformer = (type, id, transformer) => {\n    const displayType = type.substring(0, type.length - 1);\n    if (!untrack(() => state[type][id])) {\n      return;\n    }\n    setState(type, id, \"transformers\", transformer.id, transformer);\n  };\n  const removeTransformer = (type, id, transformerId) => {\n    const displayType = type.substring(0, type.length - 1);\n    if (!untrack(() => state[type][id])) {\n      return;\n    }\n    if (!untrack(() => state[type][id][\"transformers\"][transformerId])) {\n      return;\n    }\n    setState(type, id, \"transformers\", transformerId, void 0);\n  };\n  const addDraggable = ({\n    id,\n    node,\n    layout,\n    data\n  }) => {\n    const existingDraggable = state.draggables[id];\n    const draggable = {\n      id,\n      node,\n      layout,\n      data,\n      _pendingCleanup: false\n    };\n    let transformer;\n    if (!existingDraggable) {\n      Object.defineProperties(draggable, {\n        transformers: {\n          enumerable: true,\n          configurable: true,\n          writable: true,\n          value: {}\n        },\n        transform: {\n          enumerable: true,\n          configurable: true,\n          get: () => {\n            if (state.active.overlay) {\n              return noopTransform();\n            }\n            const transformers = Object.values(\n              state.draggables[id].transformers\n            );\n            transformers.sort((a, b) => a.order - b.order);\n            return transformers.reduce(\n              (transform, transformer2) => {\n                return transformer2.callback(transform);\n              },\n              noopTransform()\n            );\n          }\n        },\n        transformed: {\n          enumerable: true,\n          configurable: true,\n          get: () => {\n            return transformLayout(\n              state.draggables[id].layout,\n              state.draggables[id].transform\n            );\n          }\n        }\n      });\n    } else if (state.active.draggableId === id && !state.active.overlay) {\n      const layoutDelta = {\n        x: existingDraggable.layout.x - layout.x,\n        y: existingDraggable.layout.y - layout.y\n      };\n      const transformerId = \"addDraggable-existing-offset\";\n      const existingTransformer = existingDraggable.transformers[transformerId];\n      const transformOffset = existingTransformer ? existingTransformer.callback(layoutDelta) : layoutDelta;\n      transformer = {\n        id: transformerId,\n        order: 100,\n        callback: (transform) => {\n          return {\n            x: transform.x + transformOffset.x,\n            y: transform.y + transformOffset.y\n          };\n        }\n      };\n      onDragEnd(() => removeTransformer(\"draggables\", id, transformerId));\n    }\n    batch(() => {\n      setState(\"draggables\", id, draggable);\n      if (transformer) {\n        addTransformer(\"draggables\", id, transformer);\n      }\n    });\n    if (state.active.draggable) {\n      recomputeLayouts();\n    }\n  };\n  const removeDraggable = (id) => {\n    if (!untrack(() => state.draggables[id])) {\n      return;\n    }\n    setState(\"draggables\", id, \"_pendingCleanup\", true);\n    queueMicrotask(() => cleanupDraggable(id));\n  };\n  const cleanupDraggable = (id) => {\n    if (state.draggables[id]?._pendingCleanup) {\n      const cleanupActive = state.active.draggableId === id;\n      batch(() => {\n        if (cleanupActive) {\n          setState(\"active\", \"draggableId\", null);\n        }\n        setState(\"draggables\", id, void 0);\n      });\n    }\n  };\n  const addDroppable = ({\n    id,\n    node,\n    layout,\n    data\n  }) => {\n    const existingDroppable = state.droppables[id];\n    const droppable = {\n      id,\n      node,\n      layout,\n      data,\n      _pendingCleanup: false\n    };\n    if (!existingDroppable) {\n      Object.defineProperties(droppable, {\n        transformers: {\n          enumerable: true,\n          configurable: true,\n          writable: true,\n          value: {}\n        },\n        transform: {\n          enumerable: true,\n          configurable: true,\n          get: () => {\n            const transformers = Object.values(\n              state.droppables[id].transformers\n            );\n            transformers.sort((a, b) => a.order - b.order);\n            return transformers.reduce(\n              (transform, transformer) => {\n                return transformer.callback(transform);\n              },\n              noopTransform()\n            );\n          }\n        },\n        transformed: {\n          enumerable: true,\n          configurable: true,\n          get: () => {\n            return transformLayout(\n              state.droppables[id].layout,\n              state.droppables[id].transform\n            );\n          }\n        }\n      });\n    }\n    setState(\"droppables\", id, droppable);\n    if (state.active.draggable) {\n      recomputeLayouts();\n    }\n  };\n  const removeDroppable = (id) => {\n    if (!untrack(() => state.droppables[id])) {\n      return;\n    }\n    setState(\"droppables\", id, \"_pendingCleanup\", true);\n    queueMicrotask(() => cleanupDroppable(id));\n  };\n  const cleanupDroppable = (id) => {\n    if (state.droppables[id]?._pendingCleanup) {\n      const cleanupActive = state.active.droppableId === id;\n      batch(() => {\n        if (cleanupActive) {\n          setState(\"active\", \"droppableId\", null);\n        }\n        setState(\"droppables\", id, void 0);\n      });\n    }\n  };\n  const addSensor = ({ id, activators }) => {\n    setState(\"sensors\", id, {\n      id,\n      activators,\n      coordinates: {\n        origin: { x: 0, y: 0 },\n        current: { x: 0, y: 0 },\n        get delta() {\n          return {\n            x: state.sensors[id].coordinates.current.x - state.sensors[id].coordinates.origin.x,\n            y: state.sensors[id].coordinates.current.y - state.sensors[id].coordinates.origin.y\n          };\n        }\n      }\n    });\n  };\n  const removeSensor = (id) => {\n    if (!untrack(() => state.sensors[id])) {\n      return;\n    }\n    const cleanupActive = state.active.sensorId === id;\n    batch(() => {\n      if (cleanupActive) {\n        setState(\"active\", \"sensorId\", null);\n      }\n      setState(\"sensors\", id, void 0);\n    });\n  };\n  const setOverlay = ({ node, layout }) => {\n    const existing = state.active.overlay;\n    const overlay = {\n      node,\n      layout\n    };\n    if (!existing) {\n      Object.defineProperties(overlay, {\n        id: {\n          enumerable: true,\n          configurable: true,\n          get: () => state.active.draggable?.id\n        },\n        data: {\n          enumerable: true,\n          configurable: true,\n          get: () => state.active.draggable?.data\n        },\n        transformers: {\n          enumerable: true,\n          configurable: true,\n          get: () => Object.fromEntries(\n            Object.entries(\n              state.active.draggable ? state.active.draggable.transformers : {}\n            ).filter(([id]) => id !== \"addDraggable-existing-offset\")\n          )\n        },\n        transform: {\n          enumerable: true,\n          configurable: true,\n          get: () => {\n            const transformers = Object.values(\n              state.active.overlay ? state.active.overlay.transformers : []\n            );\n            transformers.sort((a, b) => a.order - b.order);\n            return transformers.reduce(\n              (transform, transformer) => {\n                return transformer.callback(transform);\n              },\n              noopTransform()\n            );\n          }\n        },\n        transformed: {\n          enumerable: true,\n          configurable: true,\n          get: () => {\n            return state.active.overlay ? transformLayout(\n              state.active.overlay.layout,\n              state.active.overlay.transform\n            ) : new Layout({ x: 0, y: 0, width: 0, height: 0 });\n          }\n        }\n      });\n    }\n    setState(\"active\", \"overlay\", overlay);\n  };\n  const clearOverlay = () => setState(\"active\", \"overlay\", null);\n  const sensorStart = (id, coordinates) => {\n    batch(() => {\n      setState(\"sensors\", id, \"coordinates\", {\n        origin: { ...coordinates },\n        current: { ...coordinates }\n      });\n      setState(\"active\", \"sensorId\", id);\n    });\n  };\n  const sensorMove = (coordinates) => {\n    const sensorId = state.active.sensorId;\n    if (!sensorId) {\n      return;\n    }\n    setState(\"sensors\", sensorId, \"coordinates\", \"current\", {\n      ...coordinates\n    });\n  };\n  const sensorEnd = () => setState(\"active\", \"sensorId\", null);\n  const draggableActivators = (draggableId, asHandlers) => {\n    const eventMap = {};\n    for (const sensor of Object.values(state.sensors)) {\n      if (sensor) {\n        for (const [type, activator] of Object.entries(sensor.activators)) {\n          eventMap[type] ??= [];\n          eventMap[type].push({\n            sensor,\n            activator\n          });\n        }\n      }\n    }\n    const listeners = {};\n    for (const key in eventMap) {\n      let handlerKey = key;\n      if (asHandlers) {\n        handlerKey = `on${key}`;\n      }\n      listeners[handlerKey] = (event) => {\n        for (const { activator } of eventMap[key]) {\n          if (state.active.sensor) {\n            break;\n          }\n          activator(event, draggableId);\n        }\n      };\n    }\n    return listeners;\n  };\n  const recomputeLayouts = () => {\n    let anyLayoutChanged = false;\n    const draggables = Object.values(state.draggables);\n    const droppables = Object.values(state.droppables);\n    const overlay = state.active.overlay;\n    batch(() => {\n      const cache = /* @__PURE__ */ new WeakMap();\n      for (const draggable of draggables) {\n        if (draggable) {\n          const currentLayout = draggable.layout;\n          if (!cache.has(draggable.node))\n            cache.set(draggable.node, elementLayout(draggable.node));\n          const layout = cache.get(draggable.node);\n          if (!layoutsAreEqual(currentLayout, layout)) {\n            setState(\"draggables\", draggable.id, \"layout\", layout);\n            anyLayoutChanged = true;\n          }\n        }\n      }\n      for (const droppable of droppables) {\n        if (droppable) {\n          const currentLayout = droppable.layout;\n          if (!cache.has(droppable.node))\n            cache.set(droppable.node, elementLayout(droppable.node));\n          const layout = cache.get(droppable.node);\n          if (!layoutsAreEqual(currentLayout, layout)) {\n            setState(\"droppables\", droppable.id, \"layout\", layout);\n            anyLayoutChanged = true;\n          }\n        }\n      }\n      if (overlay) {\n        const currentLayout = overlay.layout;\n        const layout = elementLayout(overlay.node);\n        if (!layoutsAreEqual(currentLayout, layout)) {\n          setState(\"active\", \"overlay\", \"layout\", layout);\n          anyLayoutChanged = true;\n        }\n      }\n    });\n    return anyLayoutChanged;\n  };\n  const detectCollisions = () => {\n    const draggable = state.active.overlay ?? state.active.draggable;\n    if (draggable) {\n      const droppable = props.collisionDetector(\n        draggable,\n        Object.values(state.droppables),\n        {\n          activeDroppableId: state.active.droppableId\n        }\n      );\n      const droppableId = droppable ? droppable.id : null;\n      if (state.active.droppableId !== droppableId) {\n        setState(\"active\", \"droppableId\", droppableId);\n      }\n    }\n  };\n  const dragStart = (draggableId) => {\n    const transformer = {\n      id: \"sensorMove\",\n      order: 0,\n      callback: (transform) => {\n        if (state.active.sensor) {\n          return {\n            x: transform.x + state.active.sensor.coordinates.delta.x,\n            y: transform.y + state.active.sensor.coordinates.delta.y\n          };\n        }\n        return transform;\n      }\n    };\n    recomputeLayouts();\n    batch(() => {\n      setState(\"active\", \"draggableId\", draggableId);\n      addTransformer(\"draggables\", draggableId, transformer);\n    });\n    detectCollisions();\n  };\n  const dragEnd = () => {\n    const draggableId = untrack(() => state.active.draggableId);\n    batch(() => {\n      if (draggableId !== null) {\n        removeTransformer(\"draggables\", draggableId, \"sensorMove\");\n      }\n      setState(\"active\", [\"draggableId\", \"droppableId\"], null);\n    });\n    recomputeLayouts();\n  };\n  const onDragStart = (handler) => {\n    createEffect(() => {\n      const draggable = state.active.draggable;\n      if (draggable) {\n        untrack(() => handler({ draggable }));\n      }\n    });\n  };\n  const onDragMove = (handler) => {\n    createEffect(() => {\n      const draggable = state.active.draggable;\n      if (draggable) {\n        const overlay = untrack(() => state.active.overlay);\n        Object.values(overlay ? overlay.transform : draggable.transform);\n        untrack(() => handler({ draggable, overlay }));\n      }\n    });\n  };\n  const onDragOver = (handler) => {\n    createEffect(() => {\n      const draggable = state.active.draggable;\n      const droppable = state.active.droppable;\n      if (draggable) {\n        untrack(\n          () => handler({ draggable, droppable, overlay: state.active.overlay })\n        );\n      }\n    });\n  };\n  const onDragEnd = (handler) => {\n    createEffect(\n      ({ previousDraggable, previousDroppable, previousOverlay }) => {\n        const draggable = state.active.draggable;\n        const droppable = draggable ? state.active.droppable : null;\n        const overlay = draggable ? state.active.overlay : null;\n        if (!draggable && previousDraggable) {\n          untrack(\n            () => handler({\n              draggable: previousDraggable,\n              droppable: previousDroppable,\n              overlay: previousOverlay\n            })\n          );\n        }\n        return {\n          previousDraggable: draggable,\n          previousDroppable: droppable,\n          previousOverlay: overlay\n        };\n      },\n      {\n        previousDraggable: null,\n        previousDroppable: null,\n        previousOverlay: null\n      }\n    );\n  };\n  onDragMove(() => detectCollisions());\n  props.onDragStart && onDragStart(props.onDragStart);\n  props.onDragMove && onDragMove(props.onDragMove);\n  props.onDragOver && onDragOver(props.onDragOver);\n  props.onDragEnd && onDragEnd(props.onDragEnd);\n  const actions = {\n    addTransformer,\n    removeTransformer,\n    addDraggable,\n    removeDraggable,\n    addDroppable,\n    removeDroppable,\n    addSensor,\n    removeSensor,\n    setOverlay,\n    clearOverlay,\n    recomputeLayouts,\n    detectCollisions,\n    draggableActivators,\n    sensorStart,\n    sensorMove,\n    sensorEnd,\n    dragStart,\n    dragEnd,\n    onDragStart,\n    onDragMove,\n    onDragOver,\n    onDragEnd\n  };\n  const context = [state, actions];\n  return <Context.Provider value={context}>{props.children}</Context.Provider>;\n};\nvar useDragDropContext = () => {\n  return useContext(Context) || null;\n};\n\n// src/create-pointer-sensor.ts\nimport { onCleanup, onMount } from \"solid-js\";\nvar createPointerSensor = (id = \"pointer-sensor\") => {\n  const [\n    state,\n    {\n      addSensor,\n      removeSensor,\n      sensorStart,\n      sensorMove,\n      sensorEnd,\n      dragStart,\n      dragEnd\n    }\n  ] = useDragDropContext();\n  const activationDelay = 250;\n  const activationDistance = 10;\n  onMount(() => {\n    addSensor({ id, activators: { pointerdown: attach } });\n  });\n  onCleanup(() => {\n    removeSensor(id);\n  });\n  const isActiveSensor = () => state.active.sensorId === id;\n  const initialCoordinates = { x: 0, y: 0 };\n  let activationDelayTimeoutId = null;\n  let activationDraggableId = null;\n  const attach = (event, draggableId) => {\n    if (event.button !== 0)\n      return;\n    document.addEventListener(\"pointermove\", onPointerMove);\n    document.addEventListener(\"pointerup\", onPointerUp);\n    activationDraggableId = draggableId;\n    initialCoordinates.x = event.clientX;\n    initialCoordinates.y = event.clientY;\n    activationDelayTimeoutId = window.setTimeout(onActivate, activationDelay);\n  };\n  const detach = () => {\n    if (activationDelayTimeoutId) {\n      clearTimeout(activationDelayTimeoutId);\n      activationDelayTimeoutId = null;\n    }\n    document.removeEventListener(\"pointermove\", onPointerMove);\n    document.removeEventListener(\"pointerup\", onPointerUp);\n    document.removeEventListener(\"selectionchange\", clearSelection);\n  };\n  const onActivate = () => {\n    if (!state.active.sensor) {\n      sensorStart(id, initialCoordinates);\n      dragStart(activationDraggableId);\n      clearSelection();\n      document.addEventListener(\"selectionchange\", clearSelection);\n    } else if (!isActiveSensor()) {\n      detach();\n    }\n  };\n  const onPointerMove = (event) => {\n    const coordinates = { x: event.clientX, y: event.clientY };\n    if (!state.active.sensor) {\n      const transform = {\n        x: coordinates.x - initialCoordinates.x,\n        y: coordinates.y - initialCoordinates.y\n      };\n      if (Math.sqrt(transform.x ** 2 + transform.y ** 2) > activationDistance) {\n        onActivate();\n      }\n    }\n    if (isActiveSensor()) {\n      event.preventDefault();\n      sensorMove(coordinates);\n    }\n  };\n  const onPointerUp = (event) => {\n    detach();\n    if (isActiveSensor()) {\n      event.preventDefault();\n      dragEnd();\n      sensorEnd();\n    }\n  };\n  const clearSelection = () => {\n    window.getSelection()?.removeAllRanges();\n  };\n};\n\n// src/drag-drop-sensors.tsx\nvar DragDropSensors = (props) => {\n  createPointerSensor();\n  return <>{props.children}</>;\n};\n\n// src/create-draggable.ts\nimport {\n  createEffect as createEffect2,\n  createSignal,\n  onCleanup as onCleanup2,\n  onMount as onMount2\n} from \"solid-js\";\n\n// src/style.ts\nvar layoutStyle = (layout) => {\n  return {\n    top: `${layout.y}px`,\n    left: `${layout.x}px`,\n    width: `${layout.width}px`,\n    height: `${layout.height}px`\n  };\n};\nvar transformStyle = (transform) => {\n  return { transform: `translate3d(${transform.x}px, ${transform.y}px, 0)` };\n};\nvar maybeTransformStyle = (transform) => {\n  return transformsAreEqual(transform, noopTransform()) ? {} : transformStyle(transform);\n};\n\n// src/create-draggable.ts\nvar createDraggable = (id, data = {}) => {\n  const [state, { addDraggable, removeDraggable, draggableActivators }] = useDragDropContext();\n  const [node, setNode] = createSignal(null);\n  onMount2(() => {\n    const resolvedNode = node();\n    if (resolvedNode) {\n      addDraggable({\n        id,\n        node: resolvedNode,\n        layout: elementLayout(resolvedNode),\n        data\n      });\n    }\n  });\n  onCleanup2(() => removeDraggable(id));\n  const isActiveDraggable = () => state.active.draggableId === id;\n  const transform = () => {\n    return state.draggables[id]?.transform || noopTransform();\n  };\n  const draggable = Object.defineProperties(\n    (element, accessor) => {\n      const config = accessor ? accessor() : {};\n      createEffect2(() => {\n        const resolvedNode = node();\n        const activators = draggableActivators(id);\n        if (resolvedNode) {\n          for (const key in activators) {\n            resolvedNode.addEventListener(key, activators[key]);\n          }\n        }\n        onCleanup2(() => {\n          if (resolvedNode) {\n            for (const key in activators) {\n              resolvedNode.removeEventListener(key, activators[key]);\n            }\n          }\n        });\n      });\n      setNode(element);\n      if (!config.skipTransform) {\n        createEffect2(() => {\n          const resolvedTransform = transform();\n          if (!transformsAreEqual(resolvedTransform, noopTransform())) {\n            const style = transformStyle(transform());\n            element.style.setProperty(\"transform\", style.transform ?? null);\n          } else {\n            element.style.removeProperty(\"transform\");\n          }\n        });\n      }\n    },\n    {\n      ref: {\n        enumerable: true,\n        value: setNode\n      },\n      isActiveDraggable: {\n        enumerable: true,\n        get: isActiveDraggable\n      },\n      dragActivators: {\n        enumerable: true,\n        get: () => {\n          return draggableActivators(id, true);\n        }\n      },\n      transform: {\n        enumerable: true,\n        get: transform\n      }\n    }\n  );\n  return draggable;\n};\n\n// src/create-droppable.ts\nimport {\n  createEffect as createEffect3,\n  createSignal as createSignal2,\n  onCleanup as onCleanup3,\n  onMount as onMount3\n} from \"solid-js\";\nvar createDroppable = (id, data = {}) => {\n  const [state, { addDroppable, removeDroppable }] = useDragDropContext();\n  const [node, setNode] = createSignal2(null);\n  onMount3(() => {\n    const resolvedNode = node();\n    if (resolvedNode) {\n      addDroppable({\n        id,\n        node: resolvedNode,\n        layout: elementLayout(resolvedNode),\n        data\n      });\n    }\n  });\n  onCleanup3(() => removeDroppable(id));\n  const isActiveDroppable = () => state.active.droppableId === id;\n  const transform = () => {\n    return state.droppables[id]?.transform || noopTransform();\n  };\n  const droppable = Object.defineProperties(\n    (element, accessor) => {\n      const config = accessor ? accessor() : {};\n      setNode(element);\n      if (!config.skipTransform) {\n        createEffect3(() => {\n          const resolvedTransform = transform();\n          if (!transformsAreEqual(resolvedTransform, noopTransform())) {\n            const style = transformStyle(transform());\n            element.style.setProperty(\"transform\", style.transform ?? null);\n          } else {\n            element.style.removeProperty(\"transform\");\n          }\n        });\n      }\n    },\n    {\n      ref: {\n        enumerable: true,\n        value: setNode\n      },\n      isActiveDroppable: {\n        enumerable: true,\n        get: isActiveDroppable\n      },\n      transform: {\n        enumerable: true,\n        get: transform\n      }\n    }\n  );\n  return droppable;\n};\n\n// src/drag-overlay.tsx\nimport { Portal } from \"solid-js/web\";\nimport { Show } from \"solid-js\";\nvar DragOverlay = (props) => {\n  const [state, { onDragStart, onDragEnd, setOverlay, clearOverlay }] = useDragDropContext();\n  let node;\n  onDragStart(({ draggable }) => {\n    setOverlay({\n      node: draggable.node,\n      layout: draggable.layout\n    });\n    queueMicrotask(() => {\n      if (node) {\n        const layout = elementLayout(node);\n        const delta = {\n          x: (draggable.layout.width - layout.width) / 2,\n          y: (draggable.layout.height - layout.height) / 2\n        };\n        layout.x += delta.x;\n        layout.y += delta.y;\n        setOverlay({ node, layout });\n      }\n    });\n  });\n  onDragEnd(() => queueMicrotask(clearOverlay));\n  const style = () => {\n    const overlay = state.active.overlay;\n    const draggable = state.active.draggable;\n    if (!overlay || !draggable)\n      return {};\n    return {\n      position: \"fixed\",\n      transition: \"transform 0s\",\n      top: `${overlay.layout.top}px`,\n      left: `${overlay.layout.left}px`,\n      \"min-width\": `${draggable.layout.width}px`,\n      \"min-height\": `${draggable.layout.height}px`,\n      ...transformStyle(overlay.transform),\n      ...props.style\n    };\n  };\n  return <Portal mount={document.body}><Show when={state.active.draggable}><div ref={node} class={props.class} style={style()}>{typeof props.children === \"function\" ? props.children(state.active.draggable) : props.children}</div></Show></Portal>;\n};\n\n// src/sortable-context.tsx\nimport {\n  createContext as createContext2,\n  createEffect as createEffect4,\n  untrack as untrack2,\n  useContext as useContext2\n} from \"solid-js\";\nimport { createStore as createStore2 } from \"solid-js/store\";\n\n// src/move-array-item.ts\nvar moveArrayItem = (array, fromIndex, toIndex) => {\n  const newArray = array.slice();\n  newArray.splice(toIndex, 0, ...newArray.splice(fromIndex, 1));\n  return newArray;\n};\n\n// src/sortable-context.tsx\nvar Context2 = createContext2();\nvar SortableProvider = (props) => {\n  const [dndState] = useDragDropContext();\n  const [state, setState] = createStore2({\n    initialIds: [],\n    sortedIds: []\n  });\n  const isValidIndex = (index) => {\n    return index >= 0 && index < state.initialIds.length;\n  };\n  createEffect4(() => {\n    setState(\"initialIds\", [...props.ids]);\n    setState(\"sortedIds\", [...props.ids]);\n  });\n  createEffect4(() => {\n    if (dndState.active.draggableId && dndState.active.droppableId) {\n      untrack2(() => {\n        const fromIndex = state.sortedIds.indexOf(dndState.active.draggableId);\n        const toIndex = state.initialIds.indexOf(dndState.active.droppableId);\n        if (!isValidIndex(fromIndex) || !isValidIndex(toIndex)) {\n          setState(\"sortedIds\", [...props.ids]);\n        } else if (fromIndex !== toIndex) {\n          const resorted = moveArrayItem(state.sortedIds, fromIndex, toIndex);\n          setState(\"sortedIds\", resorted);\n        }\n      });\n    } else {\n      setState(\"sortedIds\", [...props.ids]);\n    }\n  });\n  const actions = {};\n  const context = [state, actions];\n  return <Context2.Provider value={context}>{props.children}</Context2.Provider>;\n};\nvar useSortableContext = () => {\n  return useContext2(Context2) || null;\n};\n\n// src/create-sortable.ts\nimport { createEffect as createEffect5, onCleanup as onCleanup4, onMount as onMount4 } from \"solid-js\";\n\n// src/combine-refs.ts\nvar combineRefs = (setRefA, setRefB) => {\n  return (ref) => {\n    setRefA(ref);\n    setRefB(ref);\n  };\n};\n\n// src/create-sortable.ts\nvar createSortable = (id, data = {}) => {\n  const [dndState, { addTransformer, removeTransformer }] = useDragDropContext();\n  const [sortableState] = useSortableContext();\n  const draggable = createDraggable(id, data);\n  const droppable = createDroppable(id, data);\n  const setNode = combineRefs(draggable.ref, droppable.ref);\n  const initialIndex = () => sortableState.initialIds.indexOf(id);\n  const currentIndex = () => sortableState.sortedIds.indexOf(id);\n  const layoutById = (id2) => dndState.droppables[id2]?.layout || null;\n  const sortedTransform = () => {\n    const delta = noopTransform();\n    const resolvedInitialIndex = initialIndex();\n    const resolvedCurrentIndex = currentIndex();\n    if (resolvedCurrentIndex !== resolvedInitialIndex) {\n      const currentLayout = layoutById(id);\n      const targetLayout = layoutById(\n        sortableState.initialIds[resolvedCurrentIndex]\n      );\n      if (currentLayout && targetLayout) {\n        delta.x = targetLayout.x - currentLayout.x;\n        delta.y = targetLayout.y - currentLayout.y;\n      }\n    }\n    return delta;\n  };\n  const transformer = {\n    id: \"sortableOffset\",\n    order: 100,\n    callback: (transform2) => {\n      const delta = sortedTransform();\n      return { x: transform2.x + delta.x, y: transform2.y + delta.y };\n    }\n  };\n  onMount4(() => addTransformer(\"droppables\", id, transformer));\n  onCleanup4(() => removeTransformer(\"droppables\", id, transformer.id));\n  const transform = () => {\n    return (id === dndState.active.draggableId && !dndState.active.overlay ? dndState.draggables[id]?.transform : dndState.droppables[id]?.transform) || noopTransform();\n  };\n  const sortable = Object.defineProperties(\n    (element) => {\n      draggable(element, () => ({ skipTransform: true }));\n      droppable(element, () => ({ skipTransform: true }));\n      createEffect5(() => {\n        const resolvedTransform = transform();\n        if (!transformsAreEqual(resolvedTransform, noopTransform())) {\n          const style = transformStyle(transform());\n          element.style.setProperty(\"transform\", style.transform ?? null);\n        } else {\n          element.style.removeProperty(\"transform\");\n        }\n      });\n    },\n    {\n      ref: {\n        enumerable: true,\n        value: setNode\n      },\n      transform: {\n        enumerable: true,\n        get: transform\n      },\n      isActiveDraggable: {\n        enumerable: true,\n        get: () => draggable.isActiveDraggable\n      },\n      dragActivators: {\n        enumerable: true,\n        get: () => draggable.dragActivators\n      },\n      isActiveDroppable: {\n        enumerable: true,\n        get: () => droppable.isActiveDroppable\n      }\n    }\n  );\n  return sortable;\n};\n\n// src/drag-drop-debugger.tsx\nimport {\n  For,\n  mergeProps as mergeProps2,\n  onCleanup as onCleanup5,\n  onMount as onMount5,\n  Show as Show2\n} from \"solid-js\";\nimport { Portal as Portal2 } from \"solid-js/web\";\nvar Highlighter = (props) => {\n  props = mergeProps2({ color: \"red\", active: false }, props);\n  return <div\n    style={{\n      position: \"fixed\",\n      \"pointer-events\": \"none\",\n      ...layoutStyle(props.layout),\n      outline: \"1px dashed\",\n      \"outline-width\": props.active ? \"4px\" : \"1px\",\n      \"outline-color\": props.color,\n      display: \"flex\",\n      color: props.color,\n      \"align-items\": \"flex-end\",\n      \"justify-content\": \"flex-end\",\n      ...props.style\n    }}\n  >{props.id}</div>;\n};\nvar DragDropDebugger = () => {\n  const [state, { recomputeLayouts }] = useDragDropContext();\n  let ticking = false;\n  const update = () => {\n    if (!ticking) {\n      window.requestAnimationFrame(function() {\n        recomputeLayouts();\n        ticking = false;\n      });\n      ticking = true;\n    }\n  };\n  onMount5(() => {\n    document.addEventListener(\"scroll\", update);\n  });\n  onCleanup5(() => {\n    document.removeEventListener(\"scroll\", update);\n  });\n  return <Portal2 mount={document.body}>\n    <For each={Object.values(state.droppables)}>{(droppable) => droppable ? <Highlighter\n      id={droppable.id}\n      layout={droppable.layout}\n      active={droppable.id === state.active.droppableId}\n    /> : null}</For>\n    <For each={Object.values(state.draggables)}>{(draggable) => draggable ? <Highlighter\n      id={draggable.id}\n      layout={draggable.layout}\n      active={draggable.id === state.active.draggableId}\n      color=\"blue\"\n      style={{\n        \"align-items\": \"flex-start\",\n        \"justify-content\": \"flex-start\",\n        ...transformStyle(draggable.transform)\n      }}\n    /> : null}</For>\n    <Show2 when={state.active.overlay} keyed>{(overlay) => <Highlighter\n      id={overlay.id}\n      layout={overlay.layout}\n      active={true}\n      color=\"orange\"\n      style={{\n        ...transformStyle(overlay.transform)\n      }}\n    />}</Show2>\n  </Portal2>;\n};\nexport {\n  DragDropDebugger,\n  DragDropProvider,\n  DragDropSensors,\n  DragOverlay,\n  SortableProvider,\n  closestCenter,\n  closestCorners,\n  createDraggable,\n  createDroppable,\n  createPointerSensor,\n  createSortable,\n  layoutStyle,\n  maybeTransformStyle,\n  mostIntersecting,\n  transformStyle,\n  useDragDropContext,\n  useSortableContext\n};\n",
      "start": 1681131425071,
      "end": 1681131425624
    },
    {
      "name": "solid",
      "result": "import { template as _$template } from \"solid-js/web\";\nimport { style as _$style } from \"solid-js/web\";\nimport { className as _$className } from \"solid-js/web\";\nimport { effect as _$effect } from \"solid-js/web\";\nimport { insert as _$insert } from \"solid-js/web\";\nimport { use as _$use } from \"solid-js/web\";\nimport { memo as _$memo } from \"solid-js/web\";\nimport { createComponent as _$createComponent } from \"solid-js/web\";\nconst _tmpl$ = /*#__PURE__*/_$template(`<div></div>`, 2);\n// src/drag-drop-context.tsx\nimport { batch, createContext, createEffect, mergeProps, untrack, useContext } from \"solid-js\";\nimport { createStore } from \"solid-js/store\";\n\n// src/layout.ts\nvar Layout = class {\n  x;\n  y;\n  width;\n  height;\n  constructor(rect) {\n    this.x = Math.floor(rect.x);\n    this.y = Math.floor(rect.y);\n    this.width = Math.floor(rect.width);\n    this.height = Math.floor(rect.height);\n  }\n  get rect() {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height\n    };\n  }\n  get left() {\n    return this.x;\n  }\n  get top() {\n    return this.y;\n  }\n  get right() {\n    return this.x + this.width;\n  }\n  get bottom() {\n    return this.y + this.height;\n  }\n  get center() {\n    return {\n      x: this.x + this.width * 0.5,\n      y: this.y + this.height * 0.5\n    };\n  }\n  get corners() {\n    return {\n      topLeft: {\n        x: this.left,\n        y: this.top\n      },\n      topRight: {\n        x: this.right,\n        y: this.top\n      },\n      bottomRight: {\n        x: this.left,\n        y: this.bottom\n      },\n      bottomLeft: {\n        x: this.right,\n        y: this.bottom\n      }\n    };\n  }\n};\nvar elementLayout = element => {\n  let layout = new Layout(element.getBoundingClientRect());\n  const {\n    transform\n  } = getComputedStyle(element);\n  if (transform) {\n    layout = stripTransformFromLayout(layout, transform);\n  }\n  return layout;\n};\nvar stripTransformFromLayout = (layout, transform) => {\n  let translateX, translateY;\n  if (transform.startsWith(\"matrix3d(\")) {\n    const matrix = transform.slice(9, -1).split(/, /);\n    translateX = +matrix[12];\n    translateY = +matrix[13];\n  } else if (transform.startsWith(\"matrix(\")) {\n    const matrix = transform.slice(7, -1).split(/, /);\n    translateX = +matrix[4];\n    translateY = +matrix[5];\n  } else {\n    translateX = 0;\n    translateY = 0;\n  }\n  return new Layout({\n    ...layout,\n    x: layout.x - translateX,\n    y: layout.y - translateY\n  });\n};\nvar noopTransform = () => ({\n  x: 0,\n  y: 0\n});\nvar transformsAreEqual = (firstTransform, secondTransform) => {\n  return firstTransform.x === secondTransform.x && firstTransform.y === secondTransform.y;\n};\nvar transformLayout = (layout, transform) => {\n  return new Layout({\n    ...layout,\n    x: layout.x + transform.x,\n    y: layout.y + transform.y\n  });\n};\nvar distanceBetweenPoints = (firstPoint, secondPoint) => {\n  return Math.sqrt(Math.pow(firstPoint.x - secondPoint.x, 2) + Math.pow(firstPoint.y - secondPoint.y, 2));\n};\nvar intersectionRatioOfLayouts = (firstLayout, secondLayout) => {\n  const top = Math.max(firstLayout.top, secondLayout.top);\n  const left = Math.max(firstLayout.left, secondLayout.left);\n  const right = Math.min(firstLayout.right, secondLayout.right);\n  const bottom = Math.min(firstLayout.bottom, secondLayout.bottom);\n  const width = right - left;\n  const height = bottom - top;\n  if (left < right && top < bottom) {\n    const layout1Area = firstLayout.width * firstLayout.height;\n    const layout2Area = secondLayout.width * secondLayout.height;\n    const intersectionArea = width * height;\n    return intersectionArea / (layout1Area + layout2Area - intersectionArea);\n  }\n  return 0;\n};\nvar layoutsAreEqual = (firstLayout, secondLayout) => {\n  return firstLayout.x === secondLayout.x && firstLayout.y === secondLayout.y && firstLayout.width === secondLayout.width && firstLayout.height === secondLayout.height;\n};\n\n// src/collision.ts\nvar closestCenter = (draggable, droppables, context) => {\n  const point1 = draggable.transformed.center;\n  const collision = {\n    distance: Infinity,\n    droppable: null\n  };\n  for (const droppable of droppables) {\n    const distance = distanceBetweenPoints(point1, droppable.layout.center);\n    if (distance < collision.distance) {\n      collision.distance = distance;\n      collision.droppable = droppable;\n    } else if (distance === collision.distance && droppable.id === context.activeDroppableId) {\n      collision.droppable = droppable;\n    }\n  }\n  return collision.droppable;\n};\nvar closestCorners = (draggable, droppables, context) => {\n  const draggableCorners = draggable.transformed.corners;\n  const collision = {\n    distance: Infinity,\n    droppable: null\n  };\n  for (const droppable of droppables) {\n    const droppableCorners = droppable.layout.corners;\n    const distance = distanceBetweenPoints(droppableCorners.topLeft, draggableCorners.topLeft) + distanceBetweenPoints(droppableCorners.topRight, draggableCorners.topRight) + distanceBetweenPoints(droppableCorners.bottomRight, draggableCorners.bottomRight) + distanceBetweenPoints(droppableCorners.bottomLeft, draggableCorners.bottomLeft);\n    if (distance < collision.distance) {\n      collision.distance = distance;\n      collision.droppable = droppable;\n    } else if (distance === collision.distance && droppable.id === context.activeDroppableId) {\n      collision.droppable = droppable;\n    }\n  }\n  return collision.droppable;\n};\nvar mostIntersecting = (draggable, droppables, context) => {\n  const draggableLayout = draggable.transformed;\n  const collision = {\n    ratio: 0,\n    droppable: null\n  };\n  for (const droppable of droppables) {\n    const ratio = intersectionRatioOfLayouts(draggableLayout, droppable.layout);\n    if (ratio > collision.ratio) {\n      collision.ratio = ratio;\n      collision.droppable = droppable;\n    } else if (ratio > 0 && ratio === collision.ratio && droppable.id === context.activeDroppableId) {\n      collision.droppable = droppable;\n    }\n  }\n  return collision.droppable;\n};\n\n// src/drag-drop-context.tsx\nvar Context = createContext();\nvar DragDropProvider = passedProps => {\n  const props = mergeProps({\n    collisionDetector: mostIntersecting\n  }, passedProps);\n  const [state, setState] = createStore({\n    draggables: {},\n    droppables: {},\n    sensors: {},\n    active: {\n      draggableId: null,\n      get draggable() {\n        return state.active.draggableId !== null ? state.draggables[state.active.draggableId] : null;\n      },\n      droppableId: null,\n      get droppable() {\n        return state.active.droppableId !== null ? state.droppables[state.active.droppableId] : null;\n      },\n      sensorId: null,\n      get sensor() {\n        return state.active.sensorId !== null ? state.sensors[state.active.sensorId] : null;\n      },\n      overlay: null\n    }\n  });\n  const addTransformer = (type, id, transformer) => {\n    const displayType = type.substring(0, type.length - 1);\n    if (!untrack(() => state[type][id])) {\n      return;\n    }\n    setState(type, id, \"transformers\", transformer.id, transformer);\n  };\n  const removeTransformer = (type, id, transformerId) => {\n    const displayType = type.substring(0, type.length - 1);\n    if (!untrack(() => state[type][id])) {\n      return;\n    }\n    if (!untrack(() => state[type][id][\"transformers\"][transformerId])) {\n      return;\n    }\n    setState(type, id, \"transformers\", transformerId, void 0);\n  };\n  const addDraggable = ({\n    id,\n    node,\n    layout,\n    data\n  }) => {\n    const existingDraggable = state.draggables[id];\n    const draggable = {\n      id,\n      node,\n      layout,\n      data,\n      _pendingCleanup: false\n    };\n    let transformer;\n    if (!existingDraggable) {\n      Object.defineProperties(draggable, {\n        transformers: {\n          enumerable: true,\n          configurable: true,\n          writable: true,\n          value: {}\n        },\n        transform: {\n          enumerable: true,\n          configurable: true,\n          get: () => {\n            if (state.active.overlay) {\n              return noopTransform();\n            }\n            const transformers = Object.values(state.draggables[id].transformers);\n            transformers.sort((a, b) => a.order - b.order);\n            return transformers.reduce((transform, transformer2) => {\n              return transformer2.callback(transform);\n            }, noopTransform());\n          }\n        },\n        transformed: {\n          enumerable: true,\n          configurable: true,\n          get: () => {\n            return transformLayout(state.draggables[id].layout, state.draggables[id].transform);\n          }\n        }\n      });\n    } else if (state.active.draggableId === id && !state.active.overlay) {\n      const layoutDelta = {\n        x: existingDraggable.layout.x - layout.x,\n        y: existingDraggable.layout.y - layout.y\n      };\n      const transformerId = \"addDraggable-existing-offset\";\n      const existingTransformer = existingDraggable.transformers[transformerId];\n      const transformOffset = existingTransformer ? existingTransformer.callback(layoutDelta) : layoutDelta;\n      transformer = {\n        id: transformerId,\n        order: 100,\n        callback: transform => {\n          return {\n            x: transform.x + transformOffset.x,\n            y: transform.y + transformOffset.y\n          };\n        }\n      };\n      onDragEnd(() => removeTransformer(\"draggables\", id, transformerId));\n    }\n    batch(() => {\n      setState(\"draggables\", id, draggable);\n      if (transformer) {\n        addTransformer(\"draggables\", id, transformer);\n      }\n    });\n    if (state.active.draggable) {\n      recomputeLayouts();\n    }\n  };\n  const removeDraggable = id => {\n    if (!untrack(() => state.draggables[id])) {\n      return;\n    }\n    setState(\"draggables\", id, \"_pendingCleanup\", true);\n    queueMicrotask(() => cleanupDraggable(id));\n  };\n  const cleanupDraggable = id => {\n    if (state.draggables[id]?._pendingCleanup) {\n      const cleanupActive = state.active.draggableId === id;\n      batch(() => {\n        if (cleanupActive) {\n          setState(\"active\", \"draggableId\", null);\n        }\n        setState(\"draggables\", id, void 0);\n      });\n    }\n  };\n  const addDroppable = ({\n    id,\n    node,\n    layout,\n    data\n  }) => {\n    const existingDroppable = state.droppables[id];\n    const droppable = {\n      id,\n      node,\n      layout,\n      data,\n      _pendingCleanup: false\n    };\n    if (!existingDroppable) {\n      Object.defineProperties(droppable, {\n        transformers: {\n          enumerable: true,\n          configurable: true,\n          writable: true,\n          value: {}\n        },\n        transform: {\n          enumerable: true,\n          configurable: true,\n          get: () => {\n            const transformers = Object.values(state.droppables[id].transformers);\n            transformers.sort((a, b) => a.order - b.order);\n            return transformers.reduce((transform, transformer) => {\n              return transformer.callback(transform);\n            }, noopTransform());\n          }\n        },\n        transformed: {\n          enumerable: true,\n          configurable: true,\n          get: () => {\n            return transformLayout(state.droppables[id].layout, state.droppables[id].transform);\n          }\n        }\n      });\n    }\n    setState(\"droppables\", id, droppable);\n    if (state.active.draggable) {\n      recomputeLayouts();\n    }\n  };\n  const removeDroppable = id => {\n    if (!untrack(() => state.droppables[id])) {\n      return;\n    }\n    setState(\"droppables\", id, \"_pendingCleanup\", true);\n    queueMicrotask(() => cleanupDroppable(id));\n  };\n  const cleanupDroppable = id => {\n    if (state.droppables[id]?._pendingCleanup) {\n      const cleanupActive = state.active.droppableId === id;\n      batch(() => {\n        if (cleanupActive) {\n          setState(\"active\", \"droppableId\", null);\n        }\n        setState(\"droppables\", id, void 0);\n      });\n    }\n  };\n  const addSensor = ({\n    id,\n    activators\n  }) => {\n    setState(\"sensors\", id, {\n      id,\n      activators,\n      coordinates: {\n        origin: {\n          x: 0,\n          y: 0\n        },\n        current: {\n          x: 0,\n          y: 0\n        },\n        get delta() {\n          return {\n            x: state.sensors[id].coordinates.current.x - state.sensors[id].coordinates.origin.x,\n            y: state.sensors[id].coordinates.current.y - state.sensors[id].coordinates.origin.y\n          };\n        }\n      }\n    });\n  };\n  const removeSensor = id => {\n    if (!untrack(() => state.sensors[id])) {\n      return;\n    }\n    const cleanupActive = state.active.sensorId === id;\n    batch(() => {\n      if (cleanupActive) {\n        setState(\"active\", \"sensorId\", null);\n      }\n      setState(\"sensors\", id, void 0);\n    });\n  };\n  const setOverlay = ({\n    node,\n    layout\n  }) => {\n    const existing = state.active.overlay;\n    const overlay = {\n      node,\n      layout\n    };\n    if (!existing) {\n      Object.defineProperties(overlay, {\n        id: {\n          enumerable: true,\n          configurable: true,\n          get: () => state.active.draggable?.id\n        },\n        data: {\n          enumerable: true,\n          configurable: true,\n          get: () => state.active.draggable?.data\n        },\n        transformers: {\n          enumerable: true,\n          configurable: true,\n          get: () => Object.fromEntries(Object.entries(state.active.draggable ? state.active.draggable.transformers : {}).filter(([id]) => id !== \"addDraggable-existing-offset\"))\n        },\n        transform: {\n          enumerable: true,\n          configurable: true,\n          get: () => {\n            const transformers = Object.values(state.active.overlay ? state.active.overlay.transformers : []);\n            transformers.sort((a, b) => a.order - b.order);\n            return transformers.reduce((transform, transformer) => {\n              return transformer.callback(transform);\n            }, noopTransform());\n          }\n        },\n        transformed: {\n          enumerable: true,\n          configurable: true,\n          get: () => {\n            return state.active.overlay ? transformLayout(state.active.overlay.layout, state.active.overlay.transform) : new Layout({\n              x: 0,\n              y: 0,\n              width: 0,\n              height: 0\n            });\n          }\n        }\n      });\n    }\n    setState(\"active\", \"overlay\", overlay);\n  };\n  const clearOverlay = () => setState(\"active\", \"overlay\", null);\n  const sensorStart = (id, coordinates) => {\n    batch(() => {\n      setState(\"sensors\", id, \"coordinates\", {\n        origin: {\n          ...coordinates\n        },\n        current: {\n          ...coordinates\n        }\n      });\n      setState(\"active\", \"sensorId\", id);\n    });\n  };\n  const sensorMove = coordinates => {\n    const sensorId = state.active.sensorId;\n    if (!sensorId) {\n      return;\n    }\n    setState(\"sensors\", sensorId, \"coordinates\", \"current\", {\n      ...coordinates\n    });\n  };\n  const sensorEnd = () => setState(\"active\", \"sensorId\", null);\n  const draggableActivators = (draggableId, asHandlers) => {\n    const eventMap = {};\n    for (const sensor of Object.values(state.sensors)) {\n      if (sensor) {\n        for (const [type, activator] of Object.entries(sensor.activators)) {\n          eventMap[type] ??= [];\n          eventMap[type].push({\n            sensor,\n            activator\n          });\n        }\n      }\n    }\n    const listeners = {};\n    for (const key in eventMap) {\n      let handlerKey = key;\n      if (asHandlers) {\n        handlerKey = `on${key}`;\n      }\n      listeners[handlerKey] = event => {\n        for (const {\n          activator\n        } of eventMap[key]) {\n          if (state.active.sensor) {\n            break;\n          }\n          activator(event, draggableId);\n        }\n      };\n    }\n    return listeners;\n  };\n  const recomputeLayouts = () => {\n    let anyLayoutChanged = false;\n    const draggables = Object.values(state.draggables);\n    const droppables = Object.values(state.droppables);\n    const overlay = state.active.overlay;\n    batch(() => {\n      const cache = /* @__PURE__ */new WeakMap();\n      for (const draggable of draggables) {\n        if (draggable) {\n          const currentLayout = draggable.layout;\n          if (!cache.has(draggable.node)) cache.set(draggable.node, elementLayout(draggable.node));\n          const layout = cache.get(draggable.node);\n          if (!layoutsAreEqual(currentLayout, layout)) {\n            setState(\"draggables\", draggable.id, \"layout\", layout);\n            anyLayoutChanged = true;\n          }\n        }\n      }\n      for (const droppable of droppables) {\n        if (droppable) {\n          const currentLayout = droppable.layout;\n          if (!cache.has(droppable.node)) cache.set(droppable.node, elementLayout(droppable.node));\n          const layout = cache.get(droppable.node);\n          if (!layoutsAreEqual(currentLayout, layout)) {\n            setState(\"droppables\", droppable.id, \"layout\", layout);\n            anyLayoutChanged = true;\n          }\n        }\n      }\n      if (overlay) {\n        const currentLayout = overlay.layout;\n        const layout = elementLayout(overlay.node);\n        if (!layoutsAreEqual(currentLayout, layout)) {\n          setState(\"active\", \"overlay\", \"layout\", layout);\n          anyLayoutChanged = true;\n        }\n      }\n    });\n    return anyLayoutChanged;\n  };\n  const detectCollisions = () => {\n    const draggable = state.active.overlay ?? state.active.draggable;\n    if (draggable) {\n      const droppable = props.collisionDetector(draggable, Object.values(state.droppables), {\n        activeDroppableId: state.active.droppableId\n      });\n      const droppableId = droppable ? droppable.id : null;\n      if (state.active.droppableId !== droppableId) {\n        setState(\"active\", \"droppableId\", droppableId);\n      }\n    }\n  };\n  const dragStart = draggableId => {\n    const transformer = {\n      id: \"sensorMove\",\n      order: 0,\n      callback: transform => {\n        if (state.active.sensor) {\n          return {\n            x: transform.x + state.active.sensor.coordinates.delta.x,\n            y: transform.y + state.active.sensor.coordinates.delta.y\n          };\n        }\n        return transform;\n      }\n    };\n    recomputeLayouts();\n    batch(() => {\n      setState(\"active\", \"draggableId\", draggableId);\n      addTransformer(\"draggables\", draggableId, transformer);\n    });\n    detectCollisions();\n  };\n  const dragEnd = () => {\n    const draggableId = untrack(() => state.active.draggableId);\n    batch(() => {\n      if (draggableId !== null) {\n        removeTransformer(\"draggables\", draggableId, \"sensorMove\");\n      }\n      setState(\"active\", [\"draggableId\", \"droppableId\"], null);\n    });\n    recomputeLayouts();\n  };\n  const onDragStart = handler => {\n    createEffect(() => {\n      const draggable = state.active.draggable;\n      if (draggable) {\n        untrack(() => handler({\n          draggable\n        }));\n      }\n    });\n  };\n  const onDragMove = handler => {\n    createEffect(() => {\n      const draggable = state.active.draggable;\n      if (draggable) {\n        const overlay = untrack(() => state.active.overlay);\n        Object.values(overlay ? overlay.transform : draggable.transform);\n        untrack(() => handler({\n          draggable,\n          overlay\n        }));\n      }\n    });\n  };\n  const onDragOver = handler => {\n    createEffect(() => {\n      const draggable = state.active.draggable;\n      const droppable = state.active.droppable;\n      if (draggable) {\n        untrack(() => handler({\n          draggable,\n          droppable,\n          overlay: state.active.overlay\n        }));\n      }\n    });\n  };\n  const onDragEnd = handler => {\n    createEffect(({\n      previousDraggable,\n      previousDroppable,\n      previousOverlay\n    }) => {\n      const draggable = state.active.draggable;\n      const droppable = draggable ? state.active.droppable : null;\n      const overlay = draggable ? state.active.overlay : null;\n      if (!draggable && previousDraggable) {\n        untrack(() => handler({\n          draggable: previousDraggable,\n          droppable: previousDroppable,\n          overlay: previousOverlay\n        }));\n      }\n      return {\n        previousDraggable: draggable,\n        previousDroppable: droppable,\n        previousOverlay: overlay\n      };\n    }, {\n      previousDraggable: null,\n      previousDroppable: null,\n      previousOverlay: null\n    });\n  };\n  onDragMove(() => detectCollisions());\n  props.onDragStart && onDragStart(props.onDragStart);\n  props.onDragMove && onDragMove(props.onDragMove);\n  props.onDragOver && onDragOver(props.onDragOver);\n  props.onDragEnd && onDragEnd(props.onDragEnd);\n  const actions = {\n    addTransformer,\n    removeTransformer,\n    addDraggable,\n    removeDraggable,\n    addDroppable,\n    removeDroppable,\n    addSensor,\n    removeSensor,\n    setOverlay,\n    clearOverlay,\n    recomputeLayouts,\n    detectCollisions,\n    draggableActivators,\n    sensorStart,\n    sensorMove,\n    sensorEnd,\n    dragStart,\n    dragEnd,\n    onDragStart,\n    onDragMove,\n    onDragOver,\n    onDragEnd\n  };\n  const context = [state, actions];\n  return _$createComponent(Context.Provider, {\n    value: context,\n    get children() {\n      return props.children;\n    }\n  });\n};\nvar useDragDropContext = () => {\n  return useContext(Context) || null;\n};\n\n// src/create-pointer-sensor.ts\nimport { onCleanup, onMount } from \"solid-js\";\nvar createPointerSensor = (id = \"pointer-sensor\") => {\n  const [state, {\n    addSensor,\n    removeSensor,\n    sensorStart,\n    sensorMove,\n    sensorEnd,\n    dragStart,\n    dragEnd\n  }] = useDragDropContext();\n  const activationDelay = 250;\n  const activationDistance = 10;\n  onMount(() => {\n    addSensor({\n      id,\n      activators: {\n        pointerdown: attach\n      }\n    });\n  });\n  onCleanup(() => {\n    removeSensor(id);\n  });\n  const isActiveSensor = () => state.active.sensorId === id;\n  const initialCoordinates = {\n    x: 0,\n    y: 0\n  };\n  let activationDelayTimeoutId = null;\n  let activationDraggableId = null;\n  const attach = (event, draggableId) => {\n    if (event.button !== 0) return;\n    document.addEventListener(\"pointermove\", onPointerMove);\n    document.addEventListener(\"pointerup\", onPointerUp);\n    activationDraggableId = draggableId;\n    initialCoordinates.x = event.clientX;\n    initialCoordinates.y = event.clientY;\n    activationDelayTimeoutId = window.setTimeout(onActivate, activationDelay);\n  };\n  const detach = () => {\n    if (activationDelayTimeoutId) {\n      clearTimeout(activationDelayTimeoutId);\n      activationDelayTimeoutId = null;\n    }\n    document.removeEventListener(\"pointermove\", onPointerMove);\n    document.removeEventListener(\"pointerup\", onPointerUp);\n    document.removeEventListener(\"selectionchange\", clearSelection);\n  };\n  const onActivate = () => {\n    if (!state.active.sensor) {\n      sensorStart(id, initialCoordinates);\n      dragStart(activationDraggableId);\n      clearSelection();\n      document.addEventListener(\"selectionchange\", clearSelection);\n    } else if (!isActiveSensor()) {\n      detach();\n    }\n  };\n  const onPointerMove = event => {\n    const coordinates = {\n      x: event.clientX,\n      y: event.clientY\n    };\n    if (!state.active.sensor) {\n      const transform = {\n        x: coordinates.x - initialCoordinates.x,\n        y: coordinates.y - initialCoordinates.y\n      };\n      if (Math.sqrt(transform.x ** 2 + transform.y ** 2) > activationDistance) {\n        onActivate();\n      }\n    }\n    if (isActiveSensor()) {\n      event.preventDefault();\n      sensorMove(coordinates);\n    }\n  };\n  const onPointerUp = event => {\n    detach();\n    if (isActiveSensor()) {\n      event.preventDefault();\n      dragEnd();\n      sensorEnd();\n    }\n  };\n  const clearSelection = () => {\n    window.getSelection()?.removeAllRanges();\n  };\n};\n\n// src/drag-drop-sensors.tsx\nvar DragDropSensors = props => {\n  createPointerSensor();\n  return _$memo(() => props.children);\n};\n\n// src/create-draggable.ts\nimport { createEffect as createEffect2, createSignal, onCleanup as onCleanup2, onMount as onMount2 } from \"solid-js\";\n\n// src/style.ts\nvar layoutStyle = layout => {\n  return {\n    top: `${layout.y}px`,\n    left: `${layout.x}px`,\n    width: `${layout.width}px`,\n    height: `${layout.height}px`\n  };\n};\nvar transformStyle = transform => {\n  return {\n    transform: `translate3d(${transform.x}px, ${transform.y}px, 0)`\n  };\n};\nvar maybeTransformStyle = transform => {\n  return transformsAreEqual(transform, noopTransform()) ? {} : transformStyle(transform);\n};\n\n// src/create-draggable.ts\nvar createDraggable = (id, data = {}) => {\n  const [state, {\n    addDraggable,\n    removeDraggable,\n    draggableActivators\n  }] = useDragDropContext();\n  const [node, setNode] = createSignal(null);\n  onMount2(() => {\n    const resolvedNode = node();\n    if (resolvedNode) {\n      addDraggable({\n        id,\n        node: resolvedNode,\n        layout: elementLayout(resolvedNode),\n        data\n      });\n    }\n  });\n  onCleanup2(() => removeDraggable(id));\n  const isActiveDraggable = () => state.active.draggableId === id;\n  const transform = () => {\n    return state.draggables[id]?.transform || noopTransform();\n  };\n  const draggable = Object.defineProperties((element, accessor) => {\n    const config = accessor ? accessor() : {};\n    createEffect2(() => {\n      const resolvedNode = node();\n      const activators = draggableActivators(id);\n      if (resolvedNode) {\n        for (const key in activators) {\n          resolvedNode.addEventListener(key, activators[key]);\n        }\n      }\n      onCleanup2(() => {\n        if (resolvedNode) {\n          for (const key in activators) {\n            resolvedNode.removeEventListener(key, activators[key]);\n          }\n        }\n      });\n    });\n    setNode(element);\n    if (!config.skipTransform) {\n      createEffect2(() => {\n        const resolvedTransform = transform();\n        if (!transformsAreEqual(resolvedTransform, noopTransform())) {\n          const style = transformStyle(transform());\n          element.style.setProperty(\"transform\", style.transform ?? null);\n        } else {\n          element.style.removeProperty(\"transform\");\n        }\n      });\n    }\n  }, {\n    ref: {\n      enumerable: true,\n      value: setNode\n    },\n    isActiveDraggable: {\n      enumerable: true,\n      get: isActiveDraggable\n    },\n    dragActivators: {\n      enumerable: true,\n      get: () => {\n        return draggableActivators(id, true);\n      }\n    },\n    transform: {\n      enumerable: true,\n      get: transform\n    }\n  });\n  return draggable;\n};\n\n// src/create-droppable.ts\nimport { createEffect as createEffect3, createSignal as createSignal2, onCleanup as onCleanup3, onMount as onMount3 } from \"solid-js\";\nvar createDroppable = (id, data = {}) => {\n  const [state, {\n    addDroppable,\n    removeDroppable\n  }] = useDragDropContext();\n  const [node, setNode] = createSignal2(null);\n  onMount3(() => {\n    const resolvedNode = node();\n    if (resolvedNode) {\n      addDroppable({\n        id,\n        node: resolvedNode,\n        layout: elementLayout(resolvedNode),\n        data\n      });\n    }\n  });\n  onCleanup3(() => removeDroppable(id));\n  const isActiveDroppable = () => state.active.droppableId === id;\n  const transform = () => {\n    return state.droppables[id]?.transform || noopTransform();\n  };\n  const droppable = Object.defineProperties((element, accessor) => {\n    const config = accessor ? accessor() : {};\n    setNode(element);\n    if (!config.skipTransform) {\n      createEffect3(() => {\n        const resolvedTransform = transform();\n        if (!transformsAreEqual(resolvedTransform, noopTransform())) {\n          const style = transformStyle(transform());\n          element.style.setProperty(\"transform\", style.transform ?? null);\n        } else {\n          element.style.removeProperty(\"transform\");\n        }\n      });\n    }\n  }, {\n    ref: {\n      enumerable: true,\n      value: setNode\n    },\n    isActiveDroppable: {\n      enumerable: true,\n      get: isActiveDroppable\n    },\n    transform: {\n      enumerable: true,\n      get: transform\n    }\n  });\n  return droppable;\n};\n\n// src/drag-overlay.tsx\nimport { Portal } from \"solid-js/web\";\nimport { Show } from \"solid-js\";\nvar DragOverlay = props => {\n  const [state, {\n    onDragStart,\n    onDragEnd,\n    setOverlay,\n    clearOverlay\n  }] = useDragDropContext();\n  let node;\n  onDragStart(({\n    draggable\n  }) => {\n    setOverlay({\n      node: draggable.node,\n      layout: draggable.layout\n    });\n    queueMicrotask(() => {\n      if (node) {\n        const layout = elementLayout(node);\n        const delta = {\n          x: (draggable.layout.width - layout.width) / 2,\n          y: (draggable.layout.height - layout.height) / 2\n        };\n        layout.x += delta.x;\n        layout.y += delta.y;\n        setOverlay({\n          node,\n          layout\n        });\n      }\n    });\n  });\n  onDragEnd(() => queueMicrotask(clearOverlay));\n  const style = () => {\n    const overlay = state.active.overlay;\n    const draggable = state.active.draggable;\n    if (!overlay || !draggable) return {};\n    return {\n      position: \"fixed\",\n      transition: \"transform 0s\",\n      top: `${overlay.layout.top}px`,\n      left: `${overlay.layout.left}px`,\n      \"min-width\": `${draggable.layout.width}px`,\n      \"min-height\": `${draggable.layout.height}px`,\n      ...transformStyle(overlay.transform),\n      ...props.style\n    };\n  };\n  return _$createComponent(Portal, {\n    get mount() {\n      return document.body;\n    },\n    get children() {\n      return _$createComponent(Show, {\n        get when() {\n          return state.active.draggable;\n        },\n        get children() {\n          const _el$ = _tmpl$.cloneNode(true);\n          const _ref$ = node;\n          typeof _ref$ === \"function\" ? _$use(_ref$, _el$) : node = _el$;\n          _$insert(_el$, (() => {\n            const _c$ = _$memo(() => typeof props.children === \"function\");\n            return () => _c$() ? props.children(state.active.draggable) : props.children;\n          })());\n          _$effect(_p$ => {\n            const _v$ = props.class,\n              _v$2 = style();\n            _v$ !== _p$._v$ && _$className(_el$, _p$._v$ = _v$);\n            _p$._v$2 = _$style(_el$, _v$2, _p$._v$2);\n            return _p$;\n          }, {\n            _v$: undefined,\n            _v$2: undefined\n          });\n          return _el$;\n        }\n      });\n    }\n  });\n};\n\n// src/sortable-context.tsx\nimport { createContext as createContext2, createEffect as createEffect4, untrack as untrack2, useContext as useContext2 } from \"solid-js\";\nimport { createStore as createStore2 } from \"solid-js/store\";\n\n// src/move-array-item.ts\nvar moveArrayItem = (array, fromIndex, toIndex) => {\n  const newArray = array.slice();\n  newArray.splice(toIndex, 0, ...newArray.splice(fromIndex, 1));\n  return newArray;\n};\n\n// src/sortable-context.tsx\nvar Context2 = createContext2();\nvar SortableProvider = props => {\n  const [dndState] = useDragDropContext();\n  const [state, setState] = createStore2({\n    initialIds: [],\n    sortedIds: []\n  });\n  const isValidIndex = index => {\n    return index >= 0 && index < state.initialIds.length;\n  };\n  createEffect4(() => {\n    setState(\"initialIds\", [...props.ids]);\n    setState(\"sortedIds\", [...props.ids]);\n  });\n  createEffect4(() => {\n    if (dndState.active.draggableId && dndState.active.droppableId) {\n      untrack2(() => {\n        const fromIndex = state.sortedIds.indexOf(dndState.active.draggableId);\n        const toIndex = state.initialIds.indexOf(dndState.active.droppableId);\n        if (!isValidIndex(fromIndex) || !isValidIndex(toIndex)) {\n          setState(\"sortedIds\", [...props.ids]);\n        } else if (fromIndex !== toIndex) {\n          const resorted = moveArrayItem(state.sortedIds, fromIndex, toIndex);\n          setState(\"sortedIds\", resorted);\n        }\n      });\n    } else {\n      setState(\"sortedIds\", [...props.ids]);\n    }\n  });\n  const actions = {};\n  const context = [state, actions];\n  return _$createComponent(Context2.Provider, {\n    value: context,\n    get children() {\n      return props.children;\n    }\n  });\n};\nvar useSortableContext = () => {\n  return useContext2(Context2) || null;\n};\n\n// src/create-sortable.ts\nimport { createEffect as createEffect5, onCleanup as onCleanup4, onMount as onMount4 } from \"solid-js\";\n\n// src/combine-refs.ts\nvar combineRefs = (setRefA, setRefB) => {\n  return ref => {\n    setRefA(ref);\n    setRefB(ref);\n  };\n};\n\n// src/create-sortable.ts\nvar createSortable = (id, data = {}) => {\n  const [dndState, {\n    addTransformer,\n    removeTransformer\n  }] = useDragDropContext();\n  const [sortableState] = useSortableContext();\n  const draggable = createDraggable(id, data);\n  const droppable = createDroppable(id, data);\n  const setNode = combineRefs(draggable.ref, droppable.ref);\n  const initialIndex = () => sortableState.initialIds.indexOf(id);\n  const currentIndex = () => sortableState.sortedIds.indexOf(id);\n  const layoutById = id2 => dndState.droppables[id2]?.layout || null;\n  const sortedTransform = () => {\n    const delta = noopTransform();\n    const resolvedInitialIndex = initialIndex();\n    const resolvedCurrentIndex = currentIndex();\n    if (resolvedCurrentIndex !== resolvedInitialIndex) {\n      const currentLayout = layoutById(id);\n      const targetLayout = layoutById(sortableState.initialIds[resolvedCurrentIndex]);\n      if (currentLayout && targetLayout) {\n        delta.x = targetLayout.x - currentLayout.x;\n        delta.y = targetLayout.y - currentLayout.y;\n      }\n    }\n    return delta;\n  };\n  const transformer = {\n    id: \"sortableOffset\",\n    order: 100,\n    callback: transform2 => {\n      const delta = sortedTransform();\n      return {\n        x: transform2.x + delta.x,\n        y: transform2.y + delta.y\n      };\n    }\n  };\n  onMount4(() => addTransformer(\"droppables\", id, transformer));\n  onCleanup4(() => removeTransformer(\"droppables\", id, transformer.id));\n  const transform = () => {\n    return (id === dndState.active.draggableId && !dndState.active.overlay ? dndState.draggables[id]?.transform : dndState.droppables[id]?.transform) || noopTransform();\n  };\n  const sortable = Object.defineProperties(element => {\n    draggable(element, () => ({\n      skipTransform: true\n    }));\n    droppable(element, () => ({\n      skipTransform: true\n    }));\n    createEffect5(() => {\n      const resolvedTransform = transform();\n      if (!transformsAreEqual(resolvedTransform, noopTransform())) {\n        const style = transformStyle(transform());\n        element.style.setProperty(\"transform\", style.transform ?? null);\n      } else {\n        element.style.removeProperty(\"transform\");\n      }\n    });\n  }, {\n    ref: {\n      enumerable: true,\n      value: setNode\n    },\n    transform: {\n      enumerable: true,\n      get: transform\n    },\n    isActiveDraggable: {\n      enumerable: true,\n      get: () => draggable.isActiveDraggable\n    },\n    dragActivators: {\n      enumerable: true,\n      get: () => draggable.dragActivators\n    },\n    isActiveDroppable: {\n      enumerable: true,\n      get: () => droppable.isActiveDroppable\n    }\n  });\n  return sortable;\n};\n\n// src/drag-drop-debugger.tsx\nimport { For, mergeProps as mergeProps2, onCleanup as onCleanup5, onMount as onMount5, Show as Show2 } from \"solid-js\";\nimport { Portal as Portal2 } from \"solid-js/web\";\nvar Highlighter = props => {\n  props = mergeProps2({\n    color: \"red\",\n    active: false\n  }, props);\n  return (() => {\n    const _el$2 = _tmpl$.cloneNode(true);\n    _$insert(_el$2, () => props.id);\n    _$effect(_$p => _$style(_el$2, {\n      position: \"fixed\",\n      \"pointer-events\": \"none\",\n      ...layoutStyle(props.layout),\n      outline: \"1px dashed\",\n      \"outline-width\": props.active ? \"4px\" : \"1px\",\n      \"outline-color\": props.color,\n      display: \"flex\",\n      color: props.color,\n      \"align-items\": \"flex-end\",\n      \"justify-content\": \"flex-end\",\n      ...props.style\n    }, _$p));\n    return _el$2;\n  })();\n};\nvar DragDropDebugger = () => {\n  const [state, {\n    recomputeLayouts\n  }] = useDragDropContext();\n  let ticking = false;\n  const update = () => {\n    if (!ticking) {\n      window.requestAnimationFrame(function () {\n        recomputeLayouts();\n        ticking = false;\n      });\n      ticking = true;\n    }\n  };\n  onMount5(() => {\n    document.addEventListener(\"scroll\", update);\n  });\n  onCleanup5(() => {\n    document.removeEventListener(\"scroll\", update);\n  });\n  return _$createComponent(Portal2, {\n    get mount() {\n      return document.body;\n    },\n    get children() {\n      return [_$createComponent(For, {\n        get each() {\n          return Object.values(state.droppables);\n        },\n        children: droppable => droppable ? _$createComponent(Highlighter, {\n          get id() {\n            return droppable.id;\n          },\n          get layout() {\n            return droppable.layout;\n          },\n          get active() {\n            return droppable.id === state.active.droppableId;\n          }\n        }) : null\n      }), _$createComponent(For, {\n        get each() {\n          return Object.values(state.draggables);\n        },\n        children: draggable => draggable ? _$createComponent(Highlighter, {\n          get id() {\n            return draggable.id;\n          },\n          get layout() {\n            return draggable.layout;\n          },\n          get active() {\n            return draggable.id === state.active.draggableId;\n          },\n          color: \"blue\",\n          get style() {\n            return {\n              \"align-items\": \"flex-start\",\n              \"justify-content\": \"flex-start\",\n              ...transformStyle(draggable.transform)\n            };\n          }\n        }) : null\n      }), _$createComponent(Show2, {\n        get when() {\n          return state.active.overlay;\n        },\n        keyed: true,\n        children: overlay => _$createComponent(Highlighter, {\n          get id() {\n            return overlay.id;\n          },\n          get layout() {\n            return overlay.layout;\n          },\n          active: true,\n          color: \"orange\",\n          get style() {\n            return {\n              ...transformStyle(overlay.transform)\n            };\n          }\n        })\n      })];\n    }\n  });\n};\nexport { DragDropDebugger, DragDropProvider, DragDropSensors, DragOverlay, SortableProvider, closestCenter, closestCorners, createDraggable, createDroppable, createPointerSensor, createSortable, layoutStyle, maybeTransformStyle, mostIntersecting, transformStyle, useDragDropContext, useSortableContext };",
      "start": 1681131425625,
      "end": 1681131425819
    }
  ],
  "virtual": false
}