{
  "id": "/workspaces/Velocity/src/API/AddonReader.ts",
  "deps": [],
  "plugins": [
    "vite:load-fallback",
    "vite:esbuild"
  ],
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import BareClient from \"@tomphttp/bare-client\";\nimport * as zip from \"@zip.js/zip.js\";\nimport type * as ManifestTypes from \"webextension-manifest\";\nimport { bareClient, setBareClient } from \"~/data/appState\";\nimport { ADDON_NORMALIZE_REGEX } from \"~/util\";\n\nexport default class AddonReader {\n  blob?: Blob;\n  manifest?: any;\n  ready: Promise<boolean>;\n\n  constructor(url: string) {\n    if (!bareClient()) {\n      const server =\n        typeof window.__uv$config.bare === \"string\"\n          ? window.__uv$config.bare\n          : window.__uv$config.bare[\n              Math.floor(Math.random() * window.__uv$config.bare.length)\n            ];\n      setBareClient(new BareClient(new URL(server, location.toString())));\n    }\n\n    this.ready = new Promise((accept, reject) => {\n      this.download(url)\n        .then(() => {\n          accept(true);\n        })\n        .catch(() => {\n          reject(false);\n        });\n    });\n  }\n\n  async download(url: string): Promise<void> {\n    const request = await bareClient()!.fetch(url);\n    const blob = await request.blob();\n\n    this.blob = blob;\n  }\n\n  async extractFile(\n    filename: string,\n    contentType: string\n  ): Promise<string | Blob> {\n    const zipFileReader = new zip.BlobReader(this.blob!);\n    const zipReader = new zip.ZipReader(zipFileReader);\n    const zipEntries = await zipReader.getEntries();\n\n    const entry = zipEntries.find(\n      (x) => x.filename === filename.replace(ADDON_NORMALIZE_REGEX, \"\")\n    )!;\n\n    if (!entry) {\n      throw new Error(`Unable to retrieve entry: ${filename}`);\n    }\n\n    let writer: zip.TextWriter | zip.BlobWriter;\n    switch (contentType) {\n      case \"text\":\n        writer = new zip.TextWriter();\n        break;\n      default:\n        writer = new zip.BlobWriter(contentType);\n        break;\n    }\n\n    const data = await entry.getData(writer);\n\n    await zipReader.close();\n\n    return data;\n  }\n\n  async extractManifest(): Promise<ManifestTypes.default> {\n    const manifest = (await this.extractFile(\n      \"manifest.json\",\n      \"text\"\n    )) as string;\n    try {\n      return JSON.parse(manifest);\n    } catch {\n      throw new Error(\"Unable to parse manifest.\");\n    }\n  }\n\n  get id(): Promise<string> {\n    return new Promise((resolve, reject) => {\n      this.extractFile(\"META-INF/mozilla.rsa\", \"text\")\n        .then((text) => {\n          const match = (text as string).match(\n            /{[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}}/\n          );\n\n          if (match && match[0]) {\n            resolve(match[0]);\n          } else {\n            reject();\n          }\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n  }\n}\n",
      "start": 1681131425386,
      "end": 1681131425959
    },
    {
      "name": "vite:esbuild",
      "result": "import BareClient from \"@tomphttp/bare-client\";\nimport * as zip from \"@zip.js/zip.js\";\nimport { bareClient, setBareClient } from \"~/data/appState\";\nimport { ADDON_NORMALIZE_REGEX } from \"~/util\";\nexport default class AddonReader {\n  blob;\n  manifest;\n  ready;\n  constructor(url) {\n    if (!bareClient()) {\n      const server = typeof window.__uv$config.bare === \"string\" ? window.__uv$config.bare : window.__uv$config.bare[Math.floor(Math.random() * window.__uv$config.bare.length)];\n      setBareClient(new BareClient(new URL(server, location.toString())));\n    }\n    this.ready = new Promise((accept, reject) => {\n      this.download(url).then(() => {\n        accept(true);\n      }).catch(() => {\n        reject(false);\n      });\n    });\n  }\n  async download(url) {\n    const request = await bareClient().fetch(url);\n    const blob = await request.blob();\n    this.blob = blob;\n  }\n  async extractFile(filename, contentType) {\n    const zipFileReader = new zip.BlobReader(this.blob);\n    const zipReader = new zip.ZipReader(zipFileReader);\n    const zipEntries = await zipReader.getEntries();\n    const entry = zipEntries.find(\n      (x) => x.filename === filename.replace(ADDON_NORMALIZE_REGEX, \"\")\n    );\n    if (!entry) {\n      throw new Error(`Unable to retrieve entry: ${filename}`);\n    }\n    let writer;\n    switch (contentType) {\n      case \"text\":\n        writer = new zip.TextWriter();\n        break;\n      default:\n        writer = new zip.BlobWriter(contentType);\n        break;\n    }\n    const data = await entry.getData(writer);\n    await zipReader.close();\n    return data;\n  }\n  async extractManifest() {\n    const manifest = await this.extractFile(\n      \"manifest.json\",\n      \"text\"\n    );\n    try {\n      return JSON.parse(manifest);\n    } catch {\n      throw new Error(\"Unable to parse manifest.\");\n    }\n  }\n  get id() {\n    return new Promise((resolve, reject) => {\n      this.extractFile(\"META-INF/mozilla.rsa\", \"text\").then((text) => {\n        const match = text.match(\n          /{[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}}/\n        );\n        if (match && match[0]) {\n          resolve(match[0]);\n        } else {\n          reject();\n        }\n      }).catch((e) => {\n        reject(e);\n      });\n    });\n  }\n}\n",
      "start": 1681131425959,
      "end": 1681131426002
    }
  ],
  "virtual": false
}