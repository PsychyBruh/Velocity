{
  "id": "/workspaces/Velocity/src/manager/themeManager.ts",
  "deps": [],
  "plugins": [
    "vite:load-fallback",
    "vite:esbuild"
  ],
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import Color from \"color\";\nimport mimeDB from \"mime-db\";\nimport { isServer } from \"solid-js/web\";\nimport type Manifest from \"webextension-manifest\";\nimport type { Theme } from \"webextension-manifest\";\nimport type AddonReader from \"~/API/AddonReader\";\n\nexport const defaultTheme = {\n  colors: {\n    frame: \"#1c1b22\",\n    tab_selected: \"#42414d\",\n    tab_background_text: \"white\",\n    toolbar: \"#2b2a33\",\n    toolbar_text: \"white\",\n    toolbar_field: \"#1C1B22\",\n    toolbar_field_text: \"white\",\n    tab_line: \"transparent\"\n  }\n};\n\nlet activeTheme = Object.assign({}, defaultTheme);\n\nif (!isServer) updateCssVariables(activeTheme);\n\nexport default function setTheme(manifest: Manifest, reader: AddonReader) {\n  const newTheme = Object.assign({}, activeTheme, manifest.theme);\n  updateCssVariables(newTheme, reader);\n  activeTheme = newTheme;\n  localStorage.setItem(\"theme\", JSON.stringify(activeTheme));\n}\n\nexport async function updateCssVariables(theme: Theme, reader?: AddonReader) {\n  const root = document.querySelector<HTMLElement>(\":root\")!;\n\n  root.setAttribute(\"style\", \"\");\n\n  for (let rule in theme.colors) {\n    if (rule === \"accentcolor\") rule = \"frame\";\n    if (rule === \"textcolor\") rule = \"tab_background_text\";\n\n    const cssRule = `--${rule.replace(/_/g, \"-\")}`;\n    root.style.setProperty(\n      cssRule,\n      Color(theme.colors[rule as keyof Theme[\"colors\"]]).toString()\n    );\n  }\n\n  if (theme.images && reader) {\n    for (let rule in theme.images) {\n      if (rule === \"headerURL\") rule = \"theme_frame\";\n\n      const cssRule = `--${rule.replace(/_/g, \"-\")}`;\n\n      if (rule === \"additional_backgrounds\") {\n        let property = \"\";\n        const images = theme.images.additional_backgrounds!;\n        for (const i in images) {\n          property += `url(${URL.createObjectURL(\n            await extractBlob(images[i], reader)\n          )})${images.length - 1 <= Number(i) ? \"\" : \",\"}`;\n        }\n        root.style.setProperty(cssRule, property);\n      } else {\n        const blob = URL.createObjectURL(\n          await extractBlob(theme.images[rule as keyof Theme[\"images\"]], reader)\n        );\n        root.style.setProperty(cssRule, `url(${blob})`);\n      }\n    }\n  }\n\n  if (theme.properties) {\n    for (let property in theme.properties) {\n      const cssRule = `--${property.replace(/_/g, \"-\")}`;\n      const value = (theme.properties as any)[property] as string | string[];\n      if (typeof value === \"string\") {\n        root.style.setProperty(cssRule, value);\n      } else {\n        root.style.setProperty(cssRule, value.join(\",\"));\n      }\n    }\n  }\n}\n\nasync function extractBlob(url: string, reader: AddonReader): Promise<Blob> {\n  const blob = await reader.extractFile(url, getMime(url));\n  if (typeof blob === \"string\") throw new Error(\"Unable to extract file.\");\n  return blob!;\n}\n\nfunction getMime(file: string): string {\n  const extension = file.split(/\\./i).at(-1) || \"txt\";\n  for (const mime in mimeDB) {\n    if (\n      mimeDB[mime].extensions &&\n      mimeDB[mime].extensions?.includes(extension)\n    ) {\n      return mime;\n    }\n  }\n  return \"text/plain\";\n}\n",
      "start": 1681131430840,
      "end": 1681131431093
    },
    {
      "name": "vite:esbuild",
      "result": "import Color from \"color\";\nimport mimeDB from \"mime-db\";\nimport { isServer } from \"solid-js/web\";\nexport const defaultTheme = {\n  colors: {\n    frame: \"#1c1b22\",\n    tab_selected: \"#42414d\",\n    tab_background_text: \"white\",\n    toolbar: \"#2b2a33\",\n    toolbar_text: \"white\",\n    toolbar_field: \"#1C1B22\",\n    toolbar_field_text: \"white\",\n    tab_line: \"transparent\"\n  }\n};\nlet activeTheme = Object.assign({}, defaultTheme);\nif (!isServer)\n  updateCssVariables(activeTheme);\nexport default function setTheme(manifest, reader) {\n  const newTheme = Object.assign({}, activeTheme, manifest.theme);\n  updateCssVariables(newTheme, reader);\n  activeTheme = newTheme;\n  localStorage.setItem(\"theme\", JSON.stringify(activeTheme));\n}\nexport async function updateCssVariables(theme, reader) {\n  const root = document.querySelector(\":root\");\n  root.setAttribute(\"style\", \"\");\n  for (let rule in theme.colors) {\n    if (rule === \"accentcolor\")\n      rule = \"frame\";\n    if (rule === \"textcolor\")\n      rule = \"tab_background_text\";\n    const cssRule = `--${rule.replace(/_/g, \"-\")}`;\n    root.style.setProperty(\n      cssRule,\n      Color(theme.colors[rule]).toString()\n    );\n  }\n  if (theme.images && reader) {\n    for (let rule in theme.images) {\n      if (rule === \"headerURL\")\n        rule = \"theme_frame\";\n      const cssRule = `--${rule.replace(/_/g, \"-\")}`;\n      if (rule === \"additional_backgrounds\") {\n        let property = \"\";\n        const images = theme.images.additional_backgrounds;\n        for (const i in images) {\n          property += `url(${URL.createObjectURL(\n            await extractBlob(images[i], reader)\n          )})${images.length - 1 <= Number(i) ? \"\" : \",\"}`;\n        }\n        root.style.setProperty(cssRule, property);\n      } else {\n        const blob = URL.createObjectURL(\n          await extractBlob(theme.images[rule], reader)\n        );\n        root.style.setProperty(cssRule, `url(${blob})`);\n      }\n    }\n  }\n  if (theme.properties) {\n    for (let property in theme.properties) {\n      const cssRule = `--${property.replace(/_/g, \"-\")}`;\n      const value = theme.properties[property];\n      if (typeof value === \"string\") {\n        root.style.setProperty(cssRule, value);\n      } else {\n        root.style.setProperty(cssRule, value.join(\",\"));\n      }\n    }\n  }\n}\nasync function extractBlob(url, reader) {\n  const blob = await reader.extractFile(url, getMime(url));\n  if (typeof blob === \"string\")\n    throw new Error(\"Unable to extract file.\");\n  return blob;\n}\nfunction getMime(file) {\n  const extension = file.split(/\\./i).at(-1) || \"txt\";\n  for (const mime in mimeDB) {\n    if (mimeDB[mime].extensions && mimeDB[mime].extensions?.includes(extension)) {\n      return mime;\n    }\n  }\n  return \"text/plain\";\n}\n",
      "start": 1681131431096,
      "end": 1681131431111
    }
  ],
  "virtual": false
}